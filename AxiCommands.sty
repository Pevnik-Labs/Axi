\ProvidesPackage{AxiCommands}

% Pipes - used when specifying grammars in BNF format.
\newcommand{\pipe}{\ |\ }

% Programming language.

% Types.
\newcommand{\Fun}[2]{#1 \to #2}
\newcommand{\Prod}[2]{#1 \times #2}
\newcommand{\Sum}[2]{#1 + #2}
\newcommand{\Unit}{\textbf{1}}
\newcommand{\Empty}{\textbf{0}}
\newcommand{\ForallT}[2]{\forall #1.\, #2}

% Base types.
\newcommand{\Int}{\texttt{Int}}
\newcommand{\String}{\texttt{String}}

% Commands for coloring differences in term syntax between calculi.
\newcommand{\newterm}[1]{\mathcolor{green}{#1}}
\newcommand{\termdiff}[1]{\mathcolor{red}{#1}}

% Terms.
\newcommand{\annot}[2]{(#1 : #2)}
\newcommand{\fun}[2]{\lambda #1.\, #2}
\newcommand{\app}[2]{#1\ #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}[2][]{\texttt{outl}_{#1}\ #2}
\newcommand{\outr}[2][]{\texttt{outr}_{#1}\ #2}
\newcommand{\inl}[2][]{\texttt{inl}_{#1}\ #2}
\newcommand{\inr}[2][]{\texttt{inr}_{#1}\ #2}
\newcommand{\case}[3]{\texttt{case}\ #1\ \texttt{of}\ (#2, #3)}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\emptyelim}[2][]{\Empty\texttt{-elim}_{#1}\ #2}

% Intrinsic terms.
\newcommand{\ifun}[3]{\lambda #1 : #2.\, #3}

% Dual Intrinsic terms.
\newcommand{\iapp}[3]{\texttt{app}_{#1}\ #2\ #3}
\newcommand{\icase}[5]{\texttt{case}_{#1, #2}\ #3\ \texttt{of}\ (#4, #5)}

% Polymorphic terms.
\newcommand{\tfun}[2]{\Lambda #1.\, #2}
\newcommand{\tapp}[2]{#1\ \texttt{@}#2}

% Computation.
\newcommand{\subst}[3]{#1\left[#2 := #3\right]}
\newcommand{\val}[1]{#1\ \texttt{value}}
\newcommand{\smallstep}[2]{#1 \longrightarrow #2}
\newcommand{\smallsteps}[2]{#1 \longrightarrow^* #2}
\newcommand{\bigstep}[2]{#1 \Downarrow #2}

% Hints.
\newcommand{\Hole}{\textbf{?}}
\newcommand{\hintlub}[2]{#1 \sqcup #2}
\newcommand{\hintglb}[2]{#1 \sqcap #2}
\newcommand{\hintdiff}[2]{#1 \setminus #2}
\newcommand{\hintorder}[2]{#1 \sqsubseteq #2}
\newcommand{\stricthintorder}[2]{#1 \sqsubset #2}
\newcommand{\triplehintorder}[3]{#1 \sqsubseteq #2 \sqsubseteq #3}
\newcommand{\hintfor}[1]{\texttt{hint}(#1)}
\newcommand{\termorder}[2]{#1 \sqsubseteq #2}
\newcommand{\stricttermorder}[2]{#1 \sqsubset #2}
\newcommand{\tripletermorder}[3]{#1 \sqsubseteq #2 \sqsubseteq #3}
\newcommand{\ctxorder}[2]{#1 \sqsubseteq #2}
\newcommand{\triplectxorder}[3]{#1 \sqsubseteq #2 \sqsubseteq #3}

% Subtyping.
\newcommand{\Top}{\top}
\newcommand{\Bot}{\bot}

\newcommand{\subtyping}[2]{#1 <: #2}
\newcommand{\subtypinglub}[2]{#1 \sqcup #2}
\newcommand{\subtypingglb}[2]{#1 \sqcap #2}

% Contexts.

% Typing contexts.
\newcommand{\emptytypingctx}{\cdot}
\newcommand{\extend}[3]{#1, #2 : #3}
\newcommand{\extenddef}[4]{#1, #2 : #3 := #4}
\newcommand{\extendtype}[2]{#1, #2}

% Logic.

% Propositions.

% Propositional logic.
\newcommand{\True}{\top}
\newcommand{\False}{\bot}
\newcommand{\Not}[1]{\neg #1}
\newcommand{\Or}[2]{#1 \lor #2}
\renewcommand{\And}[2]{#1 \land #2}
\newcommand{\Impl}[2]{#1 \Rightarrow #2}
\newcommand{\Iff}[2]{#1 \Leftrightarrow #2}

% Quantifiers.
\newcommand{\All}[3]{\forall #1 : #2.\, #3}
\newcommand{\Ex}[3]{\exists #1 : #2.\, #3}

% Equality.
\newcommand{\Eq}[3][]{#2 =_{#1} #3}

% Proofterms.

% Propositional logic.
\newcommand{\implintro}[2]{\textbf{assume}\ #1\ \textbf{in}\ #2}
\newcommand{\implelim}[2]{\textbf{modus-ponens}\ #1\ #2}
\newcommand{\trueintro}{\textbf{true}}
\newcommand{\falseelim}[1]{\textbf{exfalso}\ #1}
\newcommand{\notintro}[2]{\textbf{suppose-absurd}\ #1\ \textbf{in}\ #2}
\newcommand{\notelim}[2]{\textbf{absurd}\ #1\ #2}
\newcommand{\andintro}[2]{\textbf{both}\ #1\ #2}
\newcommand{\andeliml}[1]{\textbf{left-and}\ #1}
\newcommand{\andelimr}[1]{\textbf{right-and}\ #1}
\newcommand{\orintrol}[2]{\textbf{left-either}\ #1\ #2}
\newcommand{\orintror}[2]{\textbf{right-either}\ #1\ #2}
\newcommand{\orelim}[3]{\textbf{constructive-dilemma}\ #1\ #2\ #3}
\newcommand{\iffintro}[2]{\textbf{equivalence}\ #1\ #2}
\newcommand{\iffeliml}[1]{\textbf{left-iff}\ #1}
\newcommand{\iffelimr}[1]{\textbf{right-iff}\ #1}
\newcommand{\cut}[2]{#1; #2}

% Classical logic.
\newcommand{\bycontradiction}[1]{\textbf{by-contradiction}\ #1}
\newcommand{\dn}[1]{\textbf{double-negation}\ #1}

% Quantifiers.
\newcommand{\allintro}[2]{\textbf{pick-any}\ #1\ \textbf{in}\ #2}
\newcommand{\allelim}[2]{\textbf{specialize}\ #1\ \textbf{with}\ #2}
\newcommand{\exintro}[2]{\textbf{exists}\ #1\ \textbf{such that}\ #2}
\newcommand{\exelim}[3]{\textbf{pick-witness}\ #1\ \textbf{for}\ #2\ \textbf{in}\ #3}

% Equality.
\newcommand{\refl}[1]{\textbf{refl}\ #1}
\newcommand{\rewrite}[2]{\textbf{rewrite}\ #1\ \textbf{in}\ #2}
\newcommand{\funext}[1]{\textbf{funext}\ #1}

% Induction.
\newcommand{\sumind}[5]{\textbf{case}\ #1\ \textbf{of}\ (\inl{#2} \rightarrow #3, \inr{#4} \rightarrow #5)}

% Contexts.

% Assumption contexts.
\newcommand{\emptyassctx}{\cdot}
\newcommand{\assume}[2]{#1, #2}

% Judgements.

% Declarative typing.
\newcommand{\fulltyping}[3]{#1 \vdash #2 : #3}
\newcommand{\typing}[2]{\fulltyping{\Gamma}{#1}{#2}}

% Type checking (blue arrow pointing left).
\newcommand{\fullcheck}[3]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3}
\renewcommand{\check}[2]{\fullcheck{\Gamma}{#1}{#2}}

% Type inference (red arrow pointing right).
\newcommand{\fullinfer}[3]{#1 \vdash #2 \mathcolor{red}{\Rightarrow} #3}
\newcommand{\infer}[2]{\fullinfer{\Gamma}{#1}{#2}}

% Hinting.
\newcommand{\fullhinting}[4]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3 \mathcolor{red}{\Rightarrow} #4}
\newcommand{\hinting}[3]{\fullhinting{\Gamma}{#1}{#2}{#3}}

% Hinting with output context.
\newcommand{\fulloutctx}[5]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3 \mathcolor{red}{\Rightarrow} #4 \dashv #5}
\newcommand{\outctx}[3]{\fulloutctx{\Gamma}{#1}{#2}{#3}{\Gamma'}}
\newcommand{\shortoutctx}[3]{#1 \mathcolor{blue}{\Leftarrow} #2 \mathcolor{red}{\Rightarrow} #3}

% Computational equality.
\newcommand{\fullcompeq}[4]{#1 \vdash #2 \equiv #3 : #4}
\newcommand{\compeq}[3]{\fullcompeq{\Gamma}{#1}{#2}{#3}}

% Valid context.
\newcommand{\ctx}[1]{#1\ \texttt{ctx}}

% Valid type.
\newcommand{\fulltype}[2]{#1 \vdash #2\ \texttt{type}}
\newcommand{\type}[1]{\fulltype{\Gamma}{#1}}

% Valid assumption context.
\newcommand{\assctx}[2]{#1\ \vdash #2\ \texttt{valid}}

% Well-formed proposition.
\newcommand{\prop}[2]{#1 \vdash #2\ \texttt{prop}}

% Proposition holds.
\newcommand{\fullholds}[3]{#1 \pipe #2 \vdash #3}
\newcommand{\holds}[1]{\fullholds{\Gamma}{\Delta}{#1}}

% Proof judgement.
\newcommand{\fullproves}[3]{#1 \vdash #2 : #3}
\newcommand{\proves}[2]{\fullproves{\Gamma}{#1}{#2}}

% Algorithmic proof judgements.

% Proof checking.
\newcommand{\fullproofcheck}[3]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3}
\newcommand{\proofcheck}[2]{\fullproofcheck{\Gamma}{#1}{#2}}

% Proof inference.
\newcommand{\fullproofinfer}[3]{#1 \vdash #2 \mathcolor{red}{\Rightarrow} #3}
\newcommand{\proofinfer}[2]{\fullproofinfer{\Gamma}{#1}{#2}}

% Inference rules.
\newcommand{\rulename}[1]{\textsc{\footnotesize{#1}}}
\newcommand{\infrule}[3][]{\displaystyle \frac{#2}{#3} \rulename{#1}}

% Side conditions - this command semantically marks side conditions in inference rules, but otherwise does nothing.
\newcommand{\sidecond}[1]{#1}

% Proofterms.tex
\newcommand{\NDL}{\mathcal{NDL}}