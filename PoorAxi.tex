\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usetheme{Darmstadt}

\newcommand{\pipe}{\ |\ }

\newcommand{\Fun}[2]{#1 \to #2}
\newcommand{\Prod}[2]{#1 \times #2}
\newcommand{\Sum}[2]{#1 + #2}
%\newcommand{\Unit}{\textbf{1}}
%\newcommand{\Empty}{\textbf{0}}
\newcommand{\Unit}{\texttt{Unit}}
\newcommand{\Empty}{\texttt{Empty}}

\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\app}[2]{#1\ #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}[1][]{\texttt{outl}\ #1}
\newcommand{\outr}[1][]{\texttt{outr}\ #1}
\newcommand{\inl}[1][]{\texttt{inl}\ #1}
\newcommand{\inr}[1][]{\texttt{inr}\ #1}
\newcommand{\case}[3]{\texttt{case}\ #1\ \texttt{of}\ (#2, #3)}
%\newcommand{\unit}{()}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\elimEmpty}[1][]{\texttt{elim}_{\Empty}\ #1}

\newcommand{\True}{\top}
\newcommand{\False}{\bot}
\newcommand{\Not}[1]{\neg #1}
\newcommand{\Or}[2]{#1 \lor #2}
\renewcommand{\And}[2]{#1 \land #2}
\newcommand{\Impl}[2]{#1 \Rightarrow #2}
\newcommand{\Iff}[2]{#1 \Leftrightarrow #2}

\newcommand{\All}[2]{\forall #1. #2}
\newcommand{\Ex}[2]{\exists #1. #2}

\newcommand{\Eq}[3][]{#2 =_{#1} #3}

\newcommand{\subst}[3]{#1\left[#2 := #3\right]}

\newcommand{\typing}[3]{#1 \vdash #2 : #3}
\newcommand{\computation}[4]{#1 \vdash #2 \equiv #3 : #4}
\newcommand{\prop}[2]{#1 \vdash #2\ \texttt{prop}}
\newcommand{\holds}[3]{#1 \pipe #2 \vdash #3}

\newcommand{\infrule}[3][]{\displaystyle \frac{#2}{#3} #1}

\title{STLC with Logic: Poor Man's Axi}

\begin{document}

\frame{\titlepage}

\section{Intro}

\begin{frame}{Intro}

These slides propose a basic calculus that could serve as a Poor Man's Axi. The system is Simply Typed Lambda Calculus with a first-order logic on top of it that lets us reason about program equality. At the end, we extend the system with booleans and natural numbers and consider adding some other additional features.

\end{frame}

\begin{frame}{Grammar}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\inl[e] \pipe \inr[e] \pipe \case{e}{x_1.e_1}{x_2.e_2} \pipe$ \\
\qquad $\unit \pipe \elimEmpty{e}$

\vspace{2em}

Types: \\
$A, B ::= \Fun{A}{B} \pipe \Prod{A}{B} \pipe \Sum{A}{B} \pipe \Unit \pipe \Empty$

\vspace{1em}

Propositions: \\
$P, Q ::=$ \\
\qquad $\True \pipe \False \pipe \Not{P} \pipe \Or{P}{Q} \pipe \And{P}{Q} \pipe \Impl{P}{Q} \pipe \Iff{P}{Q} \pipe$ \\
\qquad $\All{x : A}{P} \pipe \Ex{x : A}{P} \pipe$ \\
\qquad $\Eq[A]{e_1}{e_2}$

\end{frame}

\begin{frame}{Contexts}

Typing contexts: \\
$\Gamma ::= \cdot \pipe \Gamma, x : A$

\vspace{1em}

Assumption contexts: \\
$\Delta ::= \cdot \pipe \Delta, P$

\vspace{1em}

We make use of two kinds of contexts. Typing contexts tell us what the type of a variable is. They are used during typechecking and to see if a proposition is well-formed (since propositions can depend on term variables). Assumption contexts tell us what assumption were made. They are used during proof checking.

\end{frame}

\begin{frame}{Judgements}

\vspace{1em}

Typing judgement: \\
$\typing{\Gamma}{e}{A}$ -- in typing context $\Gamma$, term $e$ is of type $A$

\vspace{1em}

Computational equality judgement: \\
$\computation{\Gamma}{e_1}{e_2}{A}$ -- in typing context $\Gamma$, terms $e_1$ and $e_2$ are computationally equal. Intuitively, $e_1$ and $e_2$ compute to the same normal form.

\vspace{1em}

Well-formed proposition judgement: \\
$\prop{\Gamma}{P}$ -- in the typing context $\Gamma$, proposition $P$ is well-formed.

\vspace{1em}

True proposition judgement: \\
$\holds{\Gamma}{\Delta}{P}$ -- in typing context $\Gamma$ and propositional context $\Delta$, proposition $P$ holds.

\end{frame}

\section{Typing}

\begin{frame}{Typing -- basics}

We treat typing contexts $\Gamma$ as sets, so that there is no need for the so-called structural rules. The basic rule for typing is that variables have whatever type the typing context tells us.

\vspace{2em}

\begin{center}
  $\infrule[]{(x : A) \in \Gamma}{\typing{\Gamma}{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Typing -- main rules}

\begin{center}
  $\infrule{\typing{\Gamma, x : A}{e}{B}}{\typing{\Gamma}{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\typing{\Gamma}{f}{\Fun{A}{B}} \quad \typing{\Gamma}{a}{A}}{\typing{\Gamma}{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{b}{B}}{\typing{\Gamma}{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\typing{\Gamma}{e}{\Prod{A}{B}}}{\typing{\Gamma}{\outl[e]}{A}}$ \quad
  $\infrule{\typing{\Gamma}{e}{\Prod{A}{B}}}{\typing{\Gamma}{\outr[e]}{B}}$

  \vspace{2em}

  $\infrule{\typing{\Gamma}{e}{A}}{\typing{\Gamma}{\inl[e]}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{\Gamma}{e}{B}}{\typing{\Gamma}{\inr[e]}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{\Gamma}{e}{\Sum{A}{B}} \quad \typing{\Gamma, a : A}{e_1}{C} \quad \typing{\Gamma, b : B}{e_2}{C}}{\typing{\Gamma}{\case{e}{a.e_1}{b.e_2}}{C}}$

  \vspace{2em}

  $\infrule{}{\typing{\Gamma}{\unit}{\Unit}}$ \quad
  $\infrule{\typing{\Gamma}{e}{\Empty}}{\typing{\Gamma}{\elimEmpty[e]}{A}}$
\end{center}

\end{frame}

\section{Computation}

\begin{frame}{Computation -- basics}

We represent computation using the non-directed computational equality relation, which might be a bit unintuitive, but is a common practice. Note that computational equality is typed, i.e. there's a separate computational equality relation for each type. Computational equality draws its meaning from two basic kinds of rules, computation rules and uniqueness rules. Intuitively, two terms of a given type are computationally equal when they compute to the same result, where the meaning of ``compute'' is specified by the computation rules and the meaning of ``the same'' is specified by the uniqueness rules. Formally, computational equality is the congruence closure of computation and uniqueness rules, i.e. the least equivalence relation that preserves all term constructors and contains the computation and uniqueness rules.

\end{frame}

\begin{frame}{Computational equality -- substitution}

To state the computation rules, we need a substitution operation. Our notation is $\subst{e_1}{x}{e_2}$ for a term $e_1$ in which term $e_2$ was substituted for the variable $x$. Unfortunately, I'm too lazy to define substitution here, but it shouldn't be hard for you to define it yourself.

\end{frame}

\begin{frame}{Computational equality -- computation rules}

Computation rules describe the most essential computation steps. For example, what happens when we project the first element out of a pair? Note that not all types have computation rules. For example, $\Unit$ and $\Empty$ have no computation rules because there's no computation going on in these types.

\begin{center}
  $\infrule{\typing{\Gamma, x : A}{b}{B} \quad \typing{\Gamma}{a}{A}}{\computation{\Gamma}{\app{(\fun{x}{b})}{a}}{\subst{b}{x}{a}}{B}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{b}{B}}{\computation{\Gamma}{\outl[\pair{a}{b}]}{a}{A}}$ \quad
  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{b}{B}}{\computation{\Gamma}{\outr[\pair{a}{b}]}{b}{B}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma, x : A}{e_1}{C} \quad \typing{\Gamma, y : B}{e_2}{C}}{\computation{\Gamma}{\case{(\inl[a])}{x.e_1}{y.e_2}}{\subst{e_1}{x}{a}}{C}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{b}{B} \quad \typing{\Gamma, x : A}{e_1}{C} \quad \typing{\Gamma, y : B}{e_2}{C}}{\computation{\Gamma}{\case{(\inr[b])}{x.e_1}{y.e_2}}{\subst{e_2}{y}{b}}{C}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- uniqueness rules}

Uniqueness rules establish that every term of a given type is computationally equal to a constructor of the type. For example, every term of a product type is a pair. The rules for $\Unit$ and $\Empty$ are a bit broader -- they establish that all terms of these types are equal. Note that there are no uniqueness rules for sums.

\begin{center}
  $\infrule{\typing{\Gamma}{f}{\Fun{A}{B}}}{\computation{\Gamma}{f}{\fun{x}{\app{f}{x}}}{\Fun{A}{B}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e}{\Prod{A}{B}}}{\computation{\Gamma}{e}{\pair{\outl[e]}{\outr[e]}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e_1}{\Unit} \quad \typing{\Gamma}{e_2}{\Unit}}{\computation{\Gamma}{e_1}{e_2}{\Unit}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e_1}{\Empty} \quad \typing{\Gamma}{e_2}{\Empty}}{\computation{\Gamma}{e_1}{e_2}{\Empty}}$

\end{center}

\end{frame}

\begin{frame}{Computational equality -- equivalence relation}

Computational equality is an equivalence relation, i.e. it is reflexive, symmetric and transitive.

\begin{center}
  $\infrule{\typing{\Gamma}{e}{A}}{\computation{\Gamma}{e}{e}{A}}$

  \vspace{2em}

  $\infrule{\computation{\Gamma}{e_1}{e_2}{A}}{\computation{\Gamma}{e_2}{e_1}{A}}$

  \vspace{2em}

  $\infrule{\computation{\Gamma}{e_1}{e_2}{A} \quad \computation{\Gamma}{e_2}{e_3}{A}}{\computation{\Gamma}{e_1}{e_3}{A}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- congruence rules}

\begin{center}
  $\infrule{\computation{\Gamma, x : A}{e}{e'}{B}}{\computation{\Gamma}{\fun{x}{e}}{\fun{x}{e'}}{\Fun{A}{B}}}$ \quad
  $\infrule{\computation{\Gamma}{f}{f'}{\Fun{A}{B}} \quad \computation{\Gamma}{a}{a'}{A}}{\computation{\Gamma}{\app{f}{a}}{\app{f'}{a'}}{B}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{a}{a'}{A} \quad \computation{\Gamma}{b}{b'}{B}}{\computation{\Gamma}{\pair{a}{b}}{\pair{a'}{b'}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{e}{e'}{\Prod{A}{B}}}{\computation{\Gamma}{\outl[e]}{\outl[e']}{A}}$ \quad
  $\infrule{\computation{\Gamma}{e}{e'}{\Prod{A}{B}}}{\computation{\Gamma}{\outr[e]}{\outr[e']}{B}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{e}{e'}{A}}{\computation{\Gamma}{\inl[e]}{\inl[e']}{\Sum{A}{B}}}$ \quad
  $\infrule{\computation{\Gamma}{e}{e'}{B}}{\computation{\Gamma}{\inr[e]}{\inr[e']}{\Sum{A}{B}}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{e}{e'}{\Sum{A}{B}} \quad \computation{\Gamma, a : A}{e_1}{e_1'}{C} \quad \computation{\Gamma, b : B}{e_2}{e_2'}{C}}{\computation{\Gamma}{\case{e}{a.e_1}{b.e_2}}{\case{e'}{a.e_1'}{b.e_2'}}{C}}$

  \vspace{1em}

  $\infrule{}{\computation{\Gamma}{\unit}{\unit}{\Unit}}$ \quad
  $\infrule{\computation{\Gamma}{e}{e'}{\Empty}}{\computation{\Gamma}{\elimEmpty[e]}{\elimEmpty[e']}{A}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- closing remarks}

Note that because of the uniqueness rule for $\Unit$, we don't need the congruence rule for $\unit$. Moreover, we don't need the congruence rule for $\unit$ even more, because we already know that comutational equality is reflexive.

\vspace{1em}

Also note that in the congruence rule for $\Empty$, the premise is always true because of the uniqueness rule for $\Empty$, so it could be replaced with typing rules for $e$ and $e'$.

\end{frame}

\section{Logic}

\begin{frame}{Logic -- well-formed proposition judgement}

The role of the well-formed proposition judgement is twofold: to ensure that propositions are well-scoped (i.e. they don't contain free variables), and that propositional equality is formed only from well-typed terms. This judgement depends only on the typing context.

\end{frame}

\begin{frame}{Logic -- well-formed propositions}

\begin{center}
  $\infrule{}{\prop{\Gamma}{\True}}$ \quad
  $\infrule{}{\prop{\Gamma}{\False}}$

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P}}{\prop{\Gamma}{\Not{P}}}$ \\

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Or{P}{Q}}}$ \quad
  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\And{P}{Q}}}$

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Impl{P}{Q}}}$ \quad
  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Iff{P}{Q}}}$ \quad

  \vspace{1em}

  $\infrule{\prop{\Gamma, x : A}{P}}{\prop{\Gamma}{\All{x : A}{P}}}$ \quad
  $\infrule{\prop{\Gamma, x : A}{P}}{\prop{\Gamma}{\Ex{x : A}{P}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e_1}{A} \quad \typing{\Gamma}{e_2}{A}}{\prop{\Gamma}{\Eq[A]{e_1}{e_2}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- true proposition judgement}

The true proposition judgement depends on two contexts -- a typing context $\Gamma$ and an assumption context $\Delta$. We treat both of them as sets, which means we don't need any structural rules. We treat negation and equivalence as defined, so that no rules are needed to handle them. We define $\Not{P}$ to be $\Impl{P}{\False}$ and $\Iff{P}{Q}$ to be $\And{\Impl{P}{Q}}{\Impl{Q}{P}}$.

\vspace{1em}

The basic rule of our logic is that we can use assumptions from the assumption context.

\vspace{2em}

\begin{center}
  $\infrule{P \in \Delta}{\holds{\Gamma}{\Delta}{P}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- connectives}

The rules for connectives are entirely standard.

\vspace{1em}

\begin{center}
  $\infrule{\holds{\Gamma}{\Delta, P}{Q}}{\holds{\Gamma}{\Delta}{\Impl{P}{Q}}}$ \quad
  $\infrule{\holds{\Gamma}{\Delta}{\Impl{P}{Q}} \quad \holds{\Gamma}{\Delta}{P}}{\holds{\Gamma}{\Delta}{Q}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{P} \quad \holds{\Gamma}{\Delta}{Q}}{\holds{\Gamma}{\Delta}{\And{P}{Q}}}$ \quad
  $\infrule{\holds{\Gamma}{\Delta}{\And{P}{Q}}}{\holds{\Gamma}{\Delta}{P}}$ \quad
  $\infrule{\holds{\Gamma}{\Delta}{\And{P}{Q}}}{\holds{\Gamma}{\Delta}{Q}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{P}}{\holds{\Gamma}{\Delta}{\Or{P}{Q}}}$ \quad
  $\infrule{\holds{\Gamma}{\Delta}{Q}}{\holds{\Gamma}{\Delta}{\Or{P}{Q}}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\Or{P}{Q}} \quad \holds{\Gamma}{\Delta, P}{R} \quad \holds{\Gamma}{\Delta, Q}{R}}{\holds{\Gamma}{\Delta}{R}}$

  \vspace{1em}

  $\infrule{}{\holds{\Gamma}{\Delta}{\True}}$ \quad
  $\infrule{\holds{\Gamma}{\Delta}{\False}}{\holds{\Gamma}{\Delta}{P}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- substitution}

To express rules for quantifiers, we need the operation of substituting a term for a variable in a proposition. Our notation is $\subst{P}{x}{e}$ for proposition $P$ in which variable $x$ was substituted with term $e$.

\end{frame}

\begin{frame}{Logic -- quantifiers}

\begin{center}
  $\infrule{\holds{\Gamma, x : A}{\Delta}{P}}{\holds{\Gamma}{\Delta}{\All{x : A}{P}}}$ \qquad
  $\infrule{\holds{\Gamma}{\Delta}{\All{x : A}{P}} \quad \typing{\Gamma}{a}{A}}{\holds{\Gamma}{\Delta}{\subst{P}{x}{a}}}$

  \vspace{2em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \holds{\Gamma}{\Delta}{\subst{P}{x}{a}}}{\holds{\Gamma}{\Delta}{\Ex{x : A}{P}}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\Ex{x : A}{P}} \quad \holds{\Gamma, x : A}{\Delta, P}{R}}{\holds{\Gamma}{\Delta}{R}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- equality}

Propositional equality is an equivalence relation that can be substitued in proofs. Note that we handle reflexivity by referring to computational equality.

\vspace{2em}

\begin{center}
  $\infrule{\computation{\Gamma}{e_1}{e_2}{A}}{\holds{\Gamma}{\Delta}{\Eq[A]{e_1}{e_2}}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\Eq[A]{e_1}{e_2}}}{\holds{\Gamma}{\Delta}{\Eq[A]{e_2}{e_1}}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\Eq[A]{e_1}{e_2}} \quad \holds{\Gamma}{\Delta}{\Eq[A]{e_2}{e_3}}}{\holds{\Gamma}{\Delta}{\Eq[A]{e_1}{e_3}}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\Eq[A]{e_1}{e_2}} \quad \prop{\Gamma, x : A}{P} \quad \holds{\Gamma}{\Delta}{\subst{P}{x}{e_2}}}{\holds{\Gamma}{\Delta}{\subst{P}{x}{e_1}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- equality for particular types}

The general rules from the previous slide are not sufficient to prove all equations that we would like. For example, there's nothing we can use to prove function extensionality. We can fix this issue by adding rules that handle equality on a type-by-type basis. For now, the only additional rule we need concerns equality of functions, but with more types we might need more.

\vspace{1em}

\begin{center}
  $\infrule{\holds{\Gamma}{\Delta}{\All{x : A}{\Eq[B]{\app{f}{x}}{\app{g}{x}}}}}{\holds{\Gamma}{\Delta}{\Eq[\Fun{A}{B}]{f}{g}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- reasoning by cases on terms}

Note that so far, we haven't got any rules that allow reasoning by cases on terms. For example, we might want to reason by cases not on a disjunction, but on a term $e : \Sum{A}{B}$. To be able to do this, we need to add some more rules. Note that these rules are needed only for positive types (i.e. sums and the empty type), because for negative types the uniqueness rules suffice. Also, there's a slight discrepancy in the presentation between empty and sums, but don't worry about it.

\vspace{1em}

\begin{center}
  $\infrule{\typing{\Gamma}{e}{\Empty}}{\holds{\Gamma}{\Delta}{P}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma, a : A}{\Delta}{\subst{P}{x}{\inl[a]}} \quad \holds{\Gamma, b : B}{\Delta}{\subst{P}{x}{\inr[b]}}}{\holds{\Gamma}{\Delta}{\All{x : \Sum{A}{B}}{P}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- classical logic}

There are many ways to add classical logic to the system, but we'll have a rule which basically says that we can reason by cases on any proposition.

\vspace{2em}

\begin{center}
  $\infrule{\prop{\Gamma}{P} \quad \holds{\Gamma}{\Delta, P}{R} \quad \holds{\Gamma}{\Delta, \Not{P}}{R}}{\holds{\Gamma}{\Delta}{R}}$
\end{center}

\end{frame}

\section{Exercises}

\begin{frame}{Exercises}

Just seeing a system like this won't be enough to convince anybody that it makes sense. Therefore, doing some exercises would be advised:

\begin{itemize}
  \item Assume that $A$ and $B$ are arbitrary types. Define functions $\texttt{swap} : \Fun{\Prod{A}{B}}{\Prod{B}{A}}$ and $\texttt{sweep} : \Fun{\Sum{A}{B}}{\Sum{B}{A}}$ and prove that they are involutive. Are they computationally involutive, i.e. involutive up to computational equality?
  \item Can you prove that every term of a product type is a pair?
  \item Can you prove that every term of a sum type is either $\inl[a]$ or $\inr[b]$ for some $a$ and $b$?
  \item Add booleans to the language
  \item Add natural numbers to the language.
  \item Define addition of natural numbers and prove that it is associative and commutative.
  \item Write an interesting program and prove an interesting theorem about it.
\end{itemize}

\end{frame}

\section{More types}

\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\boolElim}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}

\begin{frame}{More types -- intro}

Our current menagerie of type constructors isn't very expressive. In fact, since the only base types are unit and empty, all we can do is finite types and functions between them. Let's what we need to do to add a new type constructor to our language. Note that to save space, we will omit the congruence rules for computational equality.

\end{frame}

\begin{frame}{More types -- booleans}

\begin{center}
  $\infrule{}{\typing{\Gamma}{\true}{\Bool}}$ \quad
  $\infrule{}{\typing{\Gamma}{\false}{\Bool}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e}{\Bool} \quad \typing{\Gamma}{e_1}{A} \quad \typing{\Gamma}{e_2}{A}}{\typing{\Gamma}{\boolElim{e}{e_1}{e_2}}{A}}$

  \vspace{1em}

  %$\infrule{}{\computation{\Gamma}{\true}{\true}{\Bool}}$ \quad
  %$\infrule{}{\computation{\Gamma}{\false}{\false}{\Bool}}$ \quad

  %\vspace{1em}

  %$\infrule{\computation{\Gamma}{e}{e'}{\Bool} \quad \computation{\Gamma}{e_1}{e_1'}{A} \quad \computation{\Gamma}{e_2}{e_2'}{A}}{\computation{\Gamma}{\boolElim{e}{e_1}{e_2}}{\boolElim{e'}{e_1'}{e_2'}}{A}}$

  %\vspace{1em}

  $\infrule{\typing{\Gamma}{e_1}{A} \quad \typing{\Gamma}{e_2}{A}}{\computation{\Gamma}{\boolElim{\true}{e_1}{e_2}}{e_1}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e_1}{A} \quad \typing{\Gamma}{e_2}{A}}{\computation{\Gamma}{\boolElim{\false}{e_1}{e_2}}{e_2}{A}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\subst{P}{b}{\true}} \quad \holds{\Gamma}{\Delta}{\subst{P}{b}{\false}}}{\holds{\Gamma}{\Delta}{\All{b : \Bool}{P}}}$
\end{center}

\end{frame}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\zero}{\texttt{zero}}
\renewcommand{\succ}[1][]{\texttt{succ}\ #1}
\newcommand{\elimNat}[3]{\texttt{elim}_\Nat\ #1\ #2\ #3}

\begin{frame}{More types -- natural numbers}

\begin{center}
  $\infrule{}{\typing{\Gamma}{\zero}{\Nat}}$ \quad
  $\infrule{\typing{\Gamma}{n}{\Nat}}{\typing{\Gamma}{\succ[n]}{\Nat}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{z}{A} \quad \typing{\Gamma}{s}{\Fun{A}{A}} \quad \typing{\Gamma}{n}{\Nat}}{\typing{\Gamma}{\elimNat{z}{s}{n}}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{z}{A} \quad \typing{\Gamma}{s}{\Fun{A}{A}}}{\computation{\Gamma}{\elimNat{z}{s}{\zero}}{z}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{z}{A} \quad \typing{\Gamma}{s}{\Fun{A}{A}} \quad \typing{\Gamma}{n}{\Nat}}{\computation{\Gamma}{\elimNat{z}{s}{(\succ[n])}}{\app{s}{(\elimNat{z}{s}{n})}}{A}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\subst{P}{n}{\zero}} \quad \holds{\Gamma, n' : \Nat}{\Delta, \subst{P}{n}{n'}}{\subst{P}{n}{\succ[n']}}}{\holds{\Gamma}{\Delta}{\All{n : \Nat}{P}}}$
\end{center}

\end{frame}

\newcommand{\List}[1]{\text{List}\ #1}
\newcommand{\nil}{\texttt{nil}}
\newcommand{\cons}[2]{\texttt{cons}\ #1\ #2}
\newcommand{\elimList}[3]{\texttt{fold}\ #1\ #2\ #3}

\begin{frame}{More types -- lists}

\begin{center}
  $\infrule{}{\typing{\Gamma}{\nil}{\List{A}}}$ \quad
  $\infrule{\typing{\Gamma}{h}{A} \quad \typing{\Gamma}{t}{\List{A}}}{\typing{\Gamma}{\cons{h}{t}}{\List{A}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{n}{A} \quad \typing{\Gamma}{c}{\Fun{A}{\Fun{B}{B}}} \quad \typing{\Gamma}{l}{\List{A}}}{\typing{\Gamma}{\elimList{n}{c}{l}}{B}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{n}{B} \quad \typing{\Gamma}{c}{\Fun{A}{\Fun{B}{B}}}}{\computation{\Gamma}{\elimList{n}{c}{\nil}}{n}{B}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{n}{B} \quad \typing{\Gamma}{c}{\Fun{A}{\Fun{B}{B}}} \quad \typing{\Gamma}{h}{A} \quad \typing{\Gamma}{t}{\List{A}}}{\computation{\Gamma}{\elimList{n}{c}{(\cons{h}{t})}}{\app{\app{c}{h}}{(\elimList{n}{c}{t})}}{B}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\subst{P}{l}{\nil}} \quad \holds{\Gamma, h : A, t : \List{A}}{\Delta, \subst{P}{l}{t}}{\subst{P}{l}{\cons{h}{t}}}}{\holds{\Gamma}{\Delta}{\All{l : \List{A}}{P}}}$
\end{center}

\end{frame}

\newcommand{\AxiStream}[1]{\texttt{Stream}\ #1}
\newcommand{\hd}[1][]{\texttt{hd}\ #1}
\newcommand{\tl}[1][]{\texttt{tl}\ #1}
\newcommand{\introStream}[2]{\texttt{scons}\ #1\ #2}

\begin{frame}{More types -- streams}

\begin{center}

  $\infrule{\typing{\Gamma}{s}{\AxiStream{A}}}{\typing{\Gamma}{\hd[s]}{A}}$ \quad
  $\infrule{\typing{\Gamma}{s}{\AxiStream{A}}}{\typing{\Gamma}{\tl[s]}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{f}{\Fun{A}{A}}}{\typing{\Gamma}{\introStream{a}{f}}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{f}{\Fun{A}{A}}}{\computation{\Gamma}{\hd[(\introStream{a}{f})]}{a}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{a}{A} \quad \typing{\Gamma}{f}{\Fun{A}{A}}}{\computation{\Gamma}{\tl[(\introStream{a}{f})]}{\introStream{(\app{f}{a})}{f}}{\AxiStream{A}}}$
\end{center}

\end{frame}

\begin{frame}{More types -- streams 2}

Stream do have all the congruence rules we would expect, but they don't have any uniqueness rules.

\vspace{1em}

\begin{center}

  $\infrule{\computation{\Gamma}{s}{s'}{A}}{\computation{\Gamma}{\hd[s]}{\hd[s']}{A}}$ \quad
  $\infrule{\computation{\Gamma}{s}{s'}{A}}{\computation{\Gamma}{\tl[s]}{\tl[s']}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{a}{a'}{A} \quad \computation{\Gamma}{f}{f'}{\Fun{A}{A}}}{\computation{\Gamma}{\introStream{a}{f}}{\introStream{a'}{f'}}{\AxiStream{A}}}$
\end{center}

\end{frame}

\begin{frame}{More types -- streams 3}

But the real question is, how do proofs by coinduction look like?

\vspace{1em}

\begin{center}

  %$\infrule{\holds{\Gamma}{\Delta, R}{\Eq[A]{\hd{s_1}}{\hd{s_2}}} \quad \holds{\Gamma}{\Delta, R}{\subst{\subst{R}{x}{\tl[s_1]}}{y}{\tl[s_2]}}}{\holds{\Gamma}{\Delta}{\Eq[\AxiStream{A}]{s_1}{s_2}}}$
\end{center}

\end{frame}

\section{Additional features}

\begin{frame}{Additional features -- intro}

What other features might we add to our language? Let's find out.

\end{frame}

\newcommand{\elimUnit}[2]{\texttt{elim}_{\Unit}\ #1\ #2}

\begin{frame}{Additional features -- eliminator for $\Unit$}

One little silly thing that we don't have is an eliminator for the $\Unit$ type.

\begin{center}
  $\infrule{\typing{\Gamma}{e}{A} \quad \typing{\Gamma}{u}{\Unit}}{\typing{\Gamma}{\elimUnit{e}{u}}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e}{A}}{\computation{\Gamma}{\elimUnit{e}{\unit}}{e}{A}}$

  \vspace{1em}

  $\infrule{\computation{\Gamma}{e}{e'}{A} \quad \computation{\Gamma}{u}{u'}{\Unit}}{\computation{\Gamma}{\elimUnit{e}{u}}{\elimUnit{e'}{u'}}{A}}$

  \vspace{1em}

  $\infrule{\holds{\Gamma}{\Delta}{\subst{P}{x}{\unit}}}{\holds{\Gamma}{\Delta}{\All{x : \Unit}{P}}}$
\end{center}

\end{frame}

\newcommand{\letin}[3]{\texttt{let}\ #1 = #2\ \texttt{in}\ #3}

\begin{frame}{Additional features -- let bindings}

\begin{center}
  $\infrule{\typing{\Gamma}{e_1}{A} \quad \typing{\Gamma, x : A}{e_2}{B}}{\typing{\Gamma}{\letin{x}{e_1}{e_2}}{B}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{\letin{x}{e_1}{e_2}}{A}}{\computation{\Gamma}{\letin{x}{e_1}{e_2}}{\subst{e_2}{x}{e_1}}{A}}$
\end{center}

\end{frame}

\newcommand{\ctype}[2]{#1 : #2}
\newcommand{\cdef}[3]{#1 : #2 :\equiv #3}

\begin{frame}{Additional features -- definitions in context}

We can change the definition of typing contexts to allow putting definitions in them. This can be handy for expressing let bindings and also makes fully formal derivations much shorter.

$\Gamma ::= \cdot \pipe \Gamma, \ctype{x}{A} \pipe \Gamma, \cdef{x}{A}{e}$

\vspace{1em}

\begin{center}
  $\infrule{\typing{\Gamma}{e}{A}}{\computation{\Gamma, \cdef{x}{A}{e}}{x}{e}{A}}$
\end{center}

\end{frame}

\newcommand{\annot}[2]{(#1 : #2)}

\begin{frame}{Additional features -- type annotations}

\begin{center}
  $\infrule{\typing{\Gamma}{e}{A}}{\typing{\Gamma}{\annot{e}{A}}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e}{A}}{\computation{\Gamma}{\annot{e}{A}}{e}{A}}$
\end{center}

\end{frame}

\newcommand{\recordtype}[1]{\{#1\}}
\newcommand{\record}[1]{\{#1\}}
\newcommand{\field}[2]{#1 := #2}
\newcommand{\fields}[3]{#1_{#3} := #2_{#3}}
\newcommand{\proj}[2]{#2.#1}

\begin{frame}{Additional features -- record types}

\begin{center}
  $\infrule{\forall i. \quad \typing{\Gamma}{e_i}{A_i}}{\typing{\Gamma}{\record{\fields{l}{e}{i}}}{\recordtype{\ctype{l_i}{A_i}}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{e}{R} \quad (\ctype{l}{A}) \in R}{\typing{\Gamma}{\proj{l}{e}}{A}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{\record{\fields{l}{e}{i}}}{\recordtype{\ctype{l_i}{A_i}}} \quad \exists i. l = l_i}{\computation{\Gamma}{\proj{l}{\record{\fields{l}{e}{i}}}}{e_i}{A_i}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma}{r}{\recordtype{\ctype{l_i}{A_i}}}}{\computation{\Gamma}{r}{\record{\field{l_i}{\proj{l_i}{r}}}}{\recordtype{\ctype{l_i}{A_i}}}}$
\end{center}

\end{frame}

\begin{frame}{Additional features -- variant types}

\begin{center}

\end{center}

\end{frame}

\newcommand{\subsettype}[3]{\{#1 : #2\ |\ #3\}}

\begin{frame}{Additional features -- subset types}

For a moment, let's say that types can depend on propositions. This means that we have a well-formed type judgement which depends both on typing and assumption contexts. We can now express subset types.

\vspace{1em}

\begin{center}
  $\infrule{\Gamma \vdash A\ \texttt{type} \quad \prop{\Gamma, \ctype{x}{A}}{P}}{\Gamma \vdash \subsettype{x}{A}{P}\ \texttt{type}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma \pipe \Delta}{e}{A} \quad \holds{\Gamma}{\Delta}{P}}{\typing{\Gamma \pipe \Delta}{\texttt{intro}\ e}{\subsettype{x}{A}{P}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma \pipe \Delta}{e}{\subsettype{x}{A}{P}}}{\typing{\Gamma \pipe \Delta}{\texttt{proj}\ e}{A}}$ \quad
  $\infrule{\typing{\Gamma \pipe \Delta}{e}{\subsettype{x}{A}{P}}}{\holds{\Gamma}{\Delta}{\subst{P}{x}{e}}}$

  \vspace{1em}

  $\infrule{\typing{\Gamma \pipe \Delta}{e}{\subsettype{x}{A}{P}}}{\computation{\Gamma}{\texttt{proj}\ (\texttt{intro}\ e)}{e}{A}}$
\end{center}

\end{frame}

\begin{frame}{Additional features -- quotient types}

TODO
\end{frame}

\newcommand{\subtype}[2]{#1 <: #2}

\begin{frame}{Additional features -- subtyping}

\begin{center}
  $\infrule{\subtype{A}{A'} \quad \subtype{B}{B'}}{\subtype{\Prod{A}{B}}{\Prod{A'}{B'}}}$
\end{center}

\end{frame}

\end{document}