\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usetheme{Darmstadt}

\newcommand{\pipe}{\ |\ }

\newcommand{\Fun}[2]{#1 \to #2}
\newcommand{\Prod}[2]{#1 \times #2}
\newcommand{\Sum}[2]{#1 + #2}
\newcommand{\Unit}{\texttt{Unit}}
\newcommand{\Empty}{\texttt{Empty}}

\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\app}[2]{#1\ #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}[1][]{\texttt{outl}\ #1}
\newcommand{\outr}[1][]{\texttt{outr}\ #1}
\newcommand{\inl}[1][]{\texttt{inl}\ #1}
\newcommand{\inr}[1][]{\texttt{inr}\ #1}
\newcommand{\case}[3]{\texttt{case}\ #1\ \texttt{of}\ (#2, #3)}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\elimEmpty}[1][]{\texttt{elim}_{\Empty}\ #1}

\newcommand{\True}{\top}
\newcommand{\False}{\bot}
\newcommand{\Not}[1]{\neg #1}
\newcommand{\Or}[2]{#1 \lor #2}
\renewcommand{\And}[2]{#1 \land #2}
\newcommand{\Impl}[2]{#1 \Rightarrow #2}
\newcommand{\Iff}[2]{#1 \Leftrightarrow #2}

\newcommand{\All}[3]{\forall #1 : #2. #3}
\newcommand{\Ex}[3]{\exists #1 : #2. #3}

\newcommand{\Eq}[3][]{#2 =_{#1} #3}

\newcommand{\subst}[3]{#1\left[#2 := #3\right]}

\newcommand{\tyctx}[1]{\mathcolor{brown}{#1\ \texttt{ctx}}}
\newcommand{\fulltyping}[3]{#1 \vdash #2 : #3}
\newcommand{\typing}[2]{\fulltyping{\Gamma}{#1}{#2}}
\newcommand{\fullcomputation}[4]{\mathcolor{blue}{#1 \vdash #2 \equiv #3 : #4}}
\newcommand{\computation}[3]{\fullcomputation{\Gamma}{#1}{#2}{#3}}

\newcommand{\assctx}[2]{\mathcolor{gray}{#1\ \vdash #2\ \texttt{valid}}}
\newcommand{\prop}[2]{\mathcolor{green}{#1 \vdash #2\ \texttt{prop}}}
\newcommand{\fullholds}[3]{\mathcolor{red}{#1 \pipe #2 \vdash #3}}
\newcommand{\holds}[1]{\fullholds{\Gamma}{\Delta}{#1}}

\newcommand{\infrule}[3][]{\displaystyle \frac{#2}{#3} \textsc{\footnotesize{#1}}}

\newcommand{\emptytypingctx}{\cdot}
\newcommand{\extend}[3]{#1, #2 : #3}
\newcommand{\extenddef}[4]{#1, #2 : #3 :\equiv #4}

\newcommand{\emptyassctx}{\cdot}
\newcommand{\assume}[2]{#1, #2}

\newcommand{\sidecond}[1]{\mathcolor{orange}{#1}}

\title{STLC with Logic: Poor Man's Axi}

\begin{document}

\frame{\titlepage}

\section{Intro}

\begin{frame}{Intro}

These slides propose a basic calculus that could serve as a Poor Man's Axi. The system is Simply Typed Lambda Calculus with a first-order logic on top of it that lets us reason about program equality. At the end, we extend the system with booleans and natural numbers and consider adding some other additional features.

\end{frame}

\begin{frame}{Grammar}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\inl[e] \pipe \inr[e] \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \elimEmpty{e}$

\vspace{2em}

Types: \\
$A, B ::= \Fun{A}{B} \pipe \Prod{A}{B} \pipe \Sum{A}{B} \pipe \Unit \pipe \Empty$

\vspace{1em}

Propositions: \\
$P, Q ::=$ \\
\qquad $\True \pipe \False \pipe \Not{P} \pipe \Or{P}{Q} \pipe \And{P}{Q} \pipe \Impl{P}{Q} \pipe \Iff{P}{Q} \pipe$ \\
\qquad $\All{x}{A}{P} \pipe \Ex{x}{A}{P} \pipe$ \\
\qquad $\Eq[A]{e_1}{e_2}$

\end{frame}

\begin{frame}{Contexts}

Typing contexts: \\
$\Gamma ::= \emptytypingctx \pipe \extend{\Gamma}{x}{A}$

\vspace{1em}

Assumption contexts: \\
$\Delta ::= \emptyassctx \pipe \assume{\Delta}{P}$

\vspace{1em}

We make use of two kinds of contexts. Typing contexts tell us what the type of a variable is. They are used during typechecking and to see if a proposition is well-formed (since propositions can depend on term variables). Assumption contexts tell us what assumption were made. They are used during proof checking.

\end{frame}

\begin{frame}{Judgements -- programming}

\vspace{1em}

Valid typing context judgement: \\
$\tyctx{\Gamma}$ -- $\Gamma$ is a well-formed typing context.

\vspace{1em}

Typing judgement: \\
$\typing{e}{A}$ -- in typing context $\Gamma$, term $e$ is of type $A$

\vspace{1em}

Computational equality judgement: \\
$\computation{e_1}{e_2}{A}$ -- in typing context $\Gamma$, terms $e_1$ and $e_2$ are computationally equal. Intuitively, $e_1$ and $e_2$ compute to the same normal form.

\end{frame}

\begin{frame}{Judgements -- logic}

Valid assumption context judgement: \\
$\assctx{\Gamma}{\Delta}$ -- in the typing context $\Gamma$, the assumption context $\Delta$ is valid.

\vspace{1em}

Well-formed proposition judgement: \\
$\prop{\Gamma}{P}$ -- in the typing context $\Gamma$, proposition $P$ is well-formed.

\vspace{1em}

True proposition judgement: \\
$\holds{P}$ -- in typing context $\Gamma$ and propositional context $\Delta$, proposition $P$ holds.

\end{frame}

\section{Typing}

\begin{frame}{Typing -- valid typing contexts}

The valid typing context judgement is the simplest one. The empty context is valid and we can extend a valid context $\Gamma$ with a variable $x$ of type $A$ provided that $x$ does not already occur in $\Gamma$.

\begin{center}
  $\infrule[Ctx-Empty]{}{\tyctx{\emptytypingctx}}$ \quad
  $\infrule[Ctx-Extend]{\tyctx{\Gamma} \quad \sidecond{x \notin \Gamma}}{\tyctx{\extend{\Gamma}{x}{A}}}$
\end{center}

\end{frame}

\begin{frame}{Typing -- basics}

We treat typing contexts $\Gamma$ as sets, so that there is no need for the so-called structural rules. The basic rule for typing is that variables have whatever type the typing context tells us.

\vspace{2em}

\begin{center}
  $\infrule[Var]{\tyctx{\Gamma} \quad \sidecond{(x : A) \in \Gamma}}{\typing{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Typing -- main rules}

\begin{center}
  $\infrule{\fulltyping{\extend{\Gamma}{x}{A}}{e}{B}}{\typing{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\typing{f}{\Fun{A}{B}} \quad \typing{a}{A}}{\typing{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\typing{a}{A} \quad \typing{b}{B}}{\typing{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outl[e]}{A}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outr[e]}{B}}$

  \vspace{2em}

  $\infrule{\typing{e}{A}}{\typing{\inl[e]}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{e}{B}}{\typing{\inr[e]}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Sum{A}{B}} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\typing{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{\tyctx{\Gamma}}{\typing{\unit}{\Unit}}$ \quad
  $\infrule{\typing{e}{\Empty}}{\typing{\elimEmpty[e]}{A}}$
\end{center}

\end{frame}

\section{Computation}

\begin{frame}{Computation -- basics}

We represent computation using the non-directed computational equality relation, which might be a bit unintuitive, but is a common practice. Note that computational equality is typed, i.e. there's a separate computational equality relation for each type. Computational equality draws its meaning from two basic kinds of rules, computation rules and uniqueness rules. Intuitively, two terms of a given type are computationally equal when they compute to the same result, where the meaning of ``compute'' is specified by the computation rules and the meaning of ``the same'' is specified by the uniqueness rules. Formally, computational equality is the congruence closure of computation and uniqueness rules, i.e. the least equivalence relation that preserves all term constructors and contains the computation and uniqueness rules.

\end{frame}

\begin{frame}{Computational equality -- substitution}

To state the computation rules, we need a substitution operation. Our notation is $\subst{e_1}{x}{e_2}$ for a term $e_1$ in which term $e_2$ was substituted for the variable $x$. Unfortunately, I'm too lazy to define substitution here, but it shouldn't be hard for you to define it yourself.

\end{frame}

\begin{frame}{Computational equality -- computation rules}

Computation rules describe the most essential computation steps. For example, what happens when we project the first element out of a pair? Note that not all types have computation rules. For example, $\Unit$ and $\Empty$ have no computation rules because there's no computation going on in these types.

\begin{center}
  $\infrule[App-Lam]{\fulltyping{\extend{\Gamma}{x}{A}}{b}{B} \quad \typing{a}{A}}{\computation{\app{(\fun{x}{b})}{a}}{\subst{b}{x}{a}}{B}}$

  \vspace{1em}

  $\infrule{\typing{a}{A} \quad \typing{b}{B}}{\computation{\outl[\pair{a}{b}]}{a}{A}}$ \quad
  $\infrule{\typing{a}{A} \quad \typing{b}{B}}{\computation{\outr[\pair{a}{b}]}{b}{B}}$

  \vspace{1em}

  $\infrule[Case-Inl]{\typing{a}{A} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\computation{\case{(\inl[a])}{f}{g}}{\app{f}{a}}{C}}$

  \vspace{1em}

  $\infrule[Case-Inr]{\typing{a}{A} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\computation{\case{(\inr[b])}{f}{g}}{\app{g}{b}}{C}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- uniqueness rules}

Uniqueness rules establish that every term of a given type is computationally equal to a constructor of the type. For example, every term of a product type is a pair. The rules for $\Unit$ and $\Empty$ are a bit broader -- they establish that all terms of these types are equal. Note that there are no uniqueness rules for sums.

\begin{center}
  $\infrule[Fun-Uniq]{\typing{f}{\Fun{A}{B}}}{\computation{f}{\fun{x}{\app{f}{x}}}{\Fun{A}{B}}}$

  \vspace{1em}

  $\infrule[Prod-Uniq]{\typing{e}{\Prod{A}{B}}}{\computation{e}{\pair{\outl[e]}{\outr[e]}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule[Unit-Uniq]{\typing{e_1}{\Unit} \quad \typing{e_2}{\Unit}}{\computation{e_1}{e_2}{\Unit}}$

  \vspace{1em}

  $\infrule[Empty-Uniq]{\typing{e_1}{\Empty} \quad \typing{e_2}{\Empty}}{\computation{e_1}{e_2}{\Empty}}$

\end{center}

\end{frame}

\begin{frame}{Computational equality -- equivalence relation}

Computational equality is an equivalence relation, i.e. it is reflexive, symmetric and transitive.

\begin{center}
  $\infrule[CompEq-Refl]{\typing{e}{A}}{\computation{e}{e}{A}}$

  \vspace{2em}

  $\infrule[CompEq-Sym]{\computation{e_1}{e_2}{A}}{\computation{e_2}{e_1}{A}}$

  \vspace{2em}

  $\infrule[CompEq-Trans]{\computation{e_1}{e_2}{A} \quad \computation{e_2}{e_3}{A}}{\computation{e_1}{e_3}{A}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- congruence rules}

\begin{center}
  $\infrule{\fullcomputation{\extend{\Gamma}{x}{A}}{e}{e'}{B}}{\computation{\fun{x}{e}}{\fun{x}{e'}}{\Fun{A}{B}}}$ \quad
  $\infrule{\computation{f}{f'}{\Fun{A}{B}} \quad \computation{a}{a'}{A}}{\computation{\app{f}{a}}{\app{f'}{a'}}{B}}$

  \vspace{1em}

  $\infrule{\computation{a}{a'}{A} \quad \computation{b}{b'}{B}}{\computation{\pair{a}{b}}{\pair{a'}{b'}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\computation{e}{e'}{\Prod{A}{B}}}{\computation{\outl[e]}{\outl[e']}{A}}$ \quad
  $\infrule{\computation{e}{e'}{\Prod{A}{B}}}{\computation{\outr[e]}{\outr[e']}{B}}$

  \vspace{1em}

  $\infrule{\computation{e}{e'}{A}}{\computation{\inl[e]}{\inl[e']}{\Sum{A}{B}}}$ \quad
  $\infrule{\computation{e}{e'}{B}}{\computation{\inr[e]}{\inr[e']}{\Sum{A}{B}}}$

  \vspace{1em}

  $\infrule{\computation{e}{e'}{\Sum{A}{B}} \quad \computation{f}{f'}{\Fun{A}{C}} \quad \computation{g}{g'}{\Fun{B}{C}}}{\computation{\case{e}{f}{g}}{\case{e'}{f'}{g'}}{C}}$

  \vspace{1em}

  $\infrule{\tyctx{\Gamma}}{\computation{\unit}{\unit}{\Unit}}$ \quad
  $\infrule{\computation{e}{e'}{\Empty}}{\computation{\elimEmpty[e]}{\elimEmpty[e']}{A}}$
\end{center}

\end{frame}

\begin{frame}{Computational equality -- closing remarks}

Note that because of the uniqueness rule for $\Unit$, we don't need the congruence rule for $\unit$. Moreover, we don't need the congruence rule for $\unit$ even more, because we already know that comutational equality is reflexive.

\vspace{1em}

Also note that in the congruence rule for $\Empty$, the premise is always true because of the uniqueness rule for $\Empty$, so it could be replaced with typing rules for $e$ and $e'$.

\end{frame}

\section{Logic}

\begin{frame}{Logic -- well-formed proposition judgement}

The role of the well-formed proposition judgement is twofold: to ensure that propositions are well-scoped (i.e. they don't contain free variables), and that propositional equality is formed only from well-typed terms. This judgement depends only on the typing context.

\end{frame}

\begin{frame}{Logic -- well-formed propositions}

\begin{center}
  $\infrule{\tyctx{\Gamma}}{\prop{\Gamma}{\True}}$ \quad
  $\infrule{\tyctx{\Gamma}}{\prop{\Gamma}{\False}}$

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P}}{\prop{\Gamma}{\Not{P}}}$ \\

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Or{P}{Q}}}$ \quad
  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\And{P}{Q}}}$

  \vspace{1em}

  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Impl{P}{Q}}}$ \quad
  $\infrule{\prop{\Gamma}{P} \quad \prop{\Gamma}{Q}}{\prop{\Gamma}{\Iff{P}{Q}}}$ \quad

  \vspace{1em}

  $\infrule{\prop{\extend{\Gamma}{x}{A}}{P}}{\prop{\Gamma}{\All{x}{A}{P}}}$ \quad
  $\infrule{\prop{\extend{\Gamma}{x}{A}}{P}}{\prop{\Gamma}{\Ex{x}{A}{P}}}$

  \vspace{1em}

  $\infrule{\typing{e_1}{A} \quad \typing{e_2}{A}}{\prop{\Gamma}{\Eq[A]{e_1}{e_2}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- valid assumption context judgement}

\begin{center}
  $\infrule[Valid-Empty]{\tyctx{\Gamma}}{\assctx{\Gamma}{\emptyassctx}}$

  \vspace{1em}

  $\infrule[Valid-Extend]{\assctx{\Gamma}{\Delta} \quad \prop{\Gamma}{P}}{\assctx{\Gamma}{\assume{\Delta}{P}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- true proposition judgement}

The true proposition judgement depends on two contexts -- a typing context $\Gamma$ and an assumption context $\Delta$. We treat both of them as sets, which means we don't need any structural rules. We treat negation and equivalence as defined, so that no rules are needed to handle them. We define $\Not{P}$ to be $\Impl{P}{\False}$ and $\Iff{P}{Q}$ to be $\And{\Impl{P}{Q}}{\Impl{Q}{P}}$.

\vspace{1em}

The basic rule of our logic is that we can use assumptions from the assumption context.

\vspace{2em}

\begin{center}
  $\infrule[Ass]{\assctx{\Gamma}{\Delta} \quad \sidecond{P \in \Delta}}{\holds{P}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- connectives}

The rules for connectives are entirely standard.

\vspace{1em}

\begin{center}
  $\infrule{\fullholds{\Gamma}{\assume{\Delta}{P}}{Q}}{\holds{\Impl{P}{Q}}}$ \quad
  $\infrule{\holds{\Impl{P}{Q}} \quad \holds{P}}{\holds{Q}}$

  \vspace{1em}

  $\infrule{\holds{P} \quad \holds{Q}}{\holds{\And{P}{Q}}}$ \quad
  $\infrule{\holds{\And{P}{Q}}}{\holds{P}}$ \quad
  $\infrule{\holds{\And{P}{Q}}}{\holds{Q}}$

  \vspace{1em}

  $\infrule{\holds{P}}{\holds{\Or{P}{Q}}}$ \quad
  $\infrule{\holds{Q}}{\holds{\Or{P}{Q}}}$

  \vspace{1em}

  $\infrule{\holds{\Or{P}{Q}} \quad \fullholds{\Gamma}{\assume{\Delta}{P}}{R} \quad \fullholds{\Gamma}{\assume{\Delta}{Q}}{R}}{\holds{R}}$

  \vspace{1em}

  $\infrule{\assctx{\Gamma}{\Delta}}{\holds{\True}}$ \quad
  $\infrule{\holds{\False}}{\holds{P}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- substitution}

To express rules for quantifiers, we need the operation of substituting a term for a variable in a proposition. Our notation is $\subst{P}{x}{e}$ for proposition $P$ in which variable $x$ was substituted with term $e$.

\end{frame}

\begin{frame}{Logic -- quantifiers}

\begin{center}
  $\infrule[Forall-Intro]{\fullholds{\extend{\Gamma}{x}{A}}{\Delta}{P}}{\holds{\All{x}{A}{P}}}$

  \vspace{1em}

  $\infrule[Forall-Elim]{\holds{\All{x}{A}{P}} \quad \typing{a}{A}}{\holds{\subst{P}{x}{a}}}$

  \vspace{2em}

  $\infrule[Exists-Intro]{\typing{a}{A} \quad \holds{\subst{P}{x}{a}}}{\holds{\Ex{x}{A}{P}}}$

  \vspace{1em}

  $\infrule[Exists-Elim]{\holds{\Ex{x}{A}{P}} \quad \fullholds{\extend{\Gamma}{x}{A}}{\assume{\Delta}{P}}{R}}{\holds{R}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- equality}

Propositional equality is an equivalence relation that can be substitued in proofs. Note that we handle reflexivity by referring to computational equality.

\vspace{2em}

\begin{center}
  $\infrule[Eq-Refl]{\assctx{\Gamma}{\Delta} \quad \computation{e_1}{e_2}{A}}{\holds{\Eq[A]{e_1}{e_2}}}$

  \vspace{1em}

  $\infrule[Eq-Sym]{\holds{\Eq[A]{e_1}{e_2}}}{\holds{\Eq[A]{e_2}{e_1}}}$

  \vspace{1em}

  $\infrule[Eq-Trans]{\holds{\Eq[A]{e_1}{e_2}} \quad \holds{\Eq[A]{e_2}{e_3}}}{\holds{\Eq[A]{e_1}{e_3}}}$

  \vspace{1em}

  $\infrule[Eq-Subst]{\holds{\Eq[A]{e_1}{e_2}} \quad \prop{\extend{\Gamma}{x}{A}}{P} \quad \holds{\subst{P}{x}{e_2}}}{\holds{\subst{P}{x}{e_1}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- equality for particular types}

The general rules from the previous slide are not sufficient to prove all equations that we would like. For example, there's nothing we can use to prove function extensionality. We can fix this issue by adding rules that handle equality on a type-by-type basis. For now, the only additional rule we need concerns equality of functions, but with more types we might need more.

\vspace{1em}

\begin{center}
  $\infrule[Funext]{\holds{\All{x}{A}{\Eq[B]{\app{f}{x}}{\app{g}{x}}}}}{\holds{\Eq[\Fun{A}{B}]{f}{g}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- reasoning by cases on terms}

Note that so far, we haven't got any rules that allow reasoning by cases on terms. For example, we might want to reason by cases not on a disjunction, but on a term $e : \Sum{A}{B}$. To be able to do this, we need to add some more rules. Note that these rules are needed only for positive types (i.e. sums and the empty type), because for negative types the uniqueness rules suffice. Also, there's a slight discrepancy in the presentation between empty and sums, but don't worry about it.

\vspace{1em}

\begin{center}
  $\infrule[Empty-Ind]{\assctx{\Gamma}{\Delta} \quad \typing{e}{\Empty}}{\holds{P}}$

  \vspace{1em}

  $\infrule[Sum-Ind]{\fullholds{\extend{\Gamma}{a}{A}}{\Delta}{\subst{P}{x}{\inl[a]}} \quad \fullholds{\extend{\Gamma}{b}{B}}{\Delta}{\subst{P}{x}{\inr[b]}}}{\holds{\All{x}{\Sum{A}{B}}{P}}}$
\end{center}

\end{frame}

\begin{frame}{Logic -- classical logic}

There are many ways to add classical logic to the system, but we'll have a rule which basically says that we can reason by cases on any proposition.

\vspace{2em}

\begin{center}
  $\infrule[Classic]{\prop{\Gamma}{P} \quad \fullholds{\Gamma}{\assume{\Delta}{P}}{R} \quad \fullholds{\Gamma}{\assume{\Delta}{\Not{P}}}{R}}{\holds{R}}$
\end{center}

\end{frame}

\section{Exercises}

\begin{frame}{Exercises}

Just seeing a system like this won't be enough to convince anybody that it makes sense. Therefore, doing some exercises would be advised:

\begin{itemize}
  \item Assume that $A$ and $B$ are arbitrary types. Define functions $\texttt{swap} : \Fun{\Prod{A}{B}}{\Prod{B}{A}}$ and $\texttt{sweep} : \Fun{\Sum{A}{B}}{\Sum{B}{A}}$ and prove that they are involutive. Are they computationally involutive, i.e. involutive up to computational equality?
  \item Can you prove that every term of a product type is a pair?
  \item Can you prove that every term of a sum type is either $\inl[a]$ or $\inr[b]$ for some $a$ and $b$?
  \item Add booleans to the language
  \item Add natural numbers to the language.
  \item Define addition of natural numbers and prove that it is associative and commutative.
  \item Write an interesting program and prove an interesting theorem about it.
\end{itemize}

\end{frame}

\section{More types}

\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\boolElim}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}

\begin{frame}{More types -- intro}

Our current menagerie of type constructors isn't very expressive. In fact, since the only base types are unit and empty, all we can do is finite types and functions between them. Let's see what we need to do to add a new type constructor to our language. Note that to save space, we will omit the congruence rules for computational equality.

\end{frame}

\newcommand{\elimUnit}[2]{\texttt{elim}_{\Unit}\ #1\ #2}

\begin{frame}{More types -- eliminator for $\Unit$}

One little silly thing that we don't have is an eliminator for the $\Unit$ type. It's useless, but why not?

\begin{center}
  $\infrule[Unit-Elim]{\typing{e}{A} \quad \typing{u}{\Unit}}{\typing{\elimUnit{e}{u}}{A}}$

  \vspace{1em}

  $\infrule[Comp-Unit]{\typing{e}{A}}{\computation{\elimUnit{e}{\unit}}{e}{A}}$

  \vspace{1em}

  $\infrule[Congr-Unit-Elim]{\computation{e}{e'}{A} \quad \computation{u}{u'}{\Unit}}{\computation{\elimUnit{e}{u}}{\elimUnit{e'}{u'}}{A}}$

  \vspace{1em}

  $\infrule[Unit-Ind]{\holds{\subst{P}{x}{\unit}}}{\holds{\All{x}{\Unit}{P}}}$
\end{center}

\end{frame}

\begin{frame}{More types -- booleans}

\begin{center}
  $\infrule{\tyctx{\Gamma}}{\typing{\true}{\Bool}}$ \quad
  $\infrule{\tyctx{\Gamma}}{\typing{\false}{\Bool}}$

  \vspace{1em}

  $\infrule[Bool-Elim]{\typing{e}{\Bool} \quad \typing{e_1}{A} \quad \typing{e_2}{A}}{\typing{\boolElim{e}{e_1}{e_2}}{A}}$

  \vspace{1em}

  %$\infrule{}{\computation{\true}{\true}{\Bool}}$ \quad
  %$\infrule{}{\computation{\false}{\false}{\Bool}}$ \quad

  %\vspace{1em}

  %$\infrule{\computation{e}{e'}{\Bool} \quad \computation{e_1}{e_1'}{A} \quad \computation{e_2}{e_2'}{A}}{\computation{\boolElim{e}{e_1}{e_2}}{\boolElim{e'}{e_1'}{e_2'}}{A}}$

  %\vspace{1em}

  $\infrule[Comp-If-True]{\typing{e_1}{A} \quad \typing{e_2}{A}}{\computation{\boolElim{\true}{e_1}{e_2}}{e_1}{A}}$

  \vspace{1em}

  $\infrule[Comp-If-False]{\typing{e_1}{A} \quad \typing{e_2}{A}}{\computation{\boolElim{\false}{e_1}{e_2}}{e_2}{A}}$

  \vspace{1em}

  $\infrule[Bool-Ind]{\holds{\subst{P}{b}{\true}} \quad \holds{\subst{P}{b}{\false}}}{\holds{\All{b}{\Bool}{P}}}$
\end{center}

\end{frame}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\zero}{\texttt{zero}}
\renewcommand{\succ}[1][]{\texttt{succ}\ #1}
\newcommand{\elimNat}[3]{\texttt{rec}_\Nat\ #1\ #2\ #3}

\begin{frame}{More types -- natural numbers}

\begin{center}
  $\infrule{\tyctx{\Gamma}}{\typing{\zero}{\Nat}}$ \quad
  $\infrule{\typing{n}{\Nat}}{\typing{\succ[n]}{\Nat}}$

  \vspace{1em}

  $\infrule[Nat-Elim]{\typing{z}{A} \quad \typing{s}{\Fun{A}{A}} \quad \typing{n}{\Nat}}{\typing{\elimNat{z}{s}{n}}{A}}$

  \vspace{1em}

  $\infrule[Rec-Zero]{\typing{z}{A} \quad \typing{s}{\Fun{A}{A}}}{\computation{\elimNat{z}{s}{\zero}}{z}{A}}$

  \vspace{1em}

  $\infrule[Rec-Succ]{\typing{z}{A} \quad \typing{s}{\Fun{A}{A}} \quad \typing{n}{\Nat}}{\computation{\elimNat{z}{s}{(\succ[n])}}{\app{s}{(\elimNat{z}{s}{n})}}{A}}$

  \vspace{1em}

  $\infrule[Nat-Ind]{\holds{\subst{P}{n}{\zero}} \quad \fullholds{\extend{\Gamma}{n'}{\Nat}}{\assume{\Delta}{\subst{P}{n}{n'}}}{\subst{P}{n}{\succ[n']}}}{\holds{\All{n}{\Nat}{P}}}$
\end{center}

\end{frame}

\newcommand{\List}[1]{\text{List}\ #1}
\newcommand{\nil}{\texttt{nil}}
\newcommand{\cons}[2]{\texttt{cons}\ #1\ #2}
\newcommand{\elimList}[3]{\texttt{fold}\ #1\ #2\ #3}

\begin{frame}{More types -- lists}

\begin{center}
  $\infrule{\tyctx{\Gamma}}{\typing{\nil}{\List{A}}}$ \quad
  $\infrule{\typing{h}{A} \quad \typing{t}{\List{A}}}{\typing{\cons{h}{t}}{\List{A}}}$

  \vspace{1em}

  $\infrule[List-Elim]{\typing{n}{A} \quad \typing{c}{\Fun{A}{\Fun{B}{B}}} \quad \typing{l}{\List{A}}}{\typing{\elimList{n}{c}{l}}{B}}$

  \vspace{1em}

  $\infrule[Fold-Nil]{\typing{n}{B} \quad \typing{c}{\Fun{A}{\Fun{B}{B}}}}{\computation{\elimList{n}{c}{\nil}}{n}{B}}$

  \vspace{1em}

  $\infrule[Fold-Cons]{\typing{n}{B} \quad \typing{c}{\Fun{A}{\Fun{B}{B}}} \quad \typing{h}{A} \quad \typing{t}{\List{A}}}{\computation{\elimList{n}{c}{(\cons{h}{t})}}{\app{\app{c}{h}}{(\elimList{n}{c}{t})}}{B}}$

  \vspace{1em}

  $\infrule[List-Ind]{\holds{\subst{P}{l}{\nil}} \quad \fullholds{\extend{\extend{\Gamma}{h}{A}}{t}{\List{A}}}{\assume{\Delta}{\subst{P}{l}{t}}}{\subst{P}{l}{\cons{h}{t}}}}{\holds{\All{l}{\List{A}}{P}}}$
\end{center}

\end{frame}

\newcommand{\AxiStream}[1]{\texttt{Stream}\ #1}
\newcommand{\hd}[1][]{\texttt{hd}\ #1}
\newcommand{\tl}[1][]{\texttt{tl}\ #1}
\newcommand{\introStream}[2]{\texttt{scons}\ #1\ #2}

\begin{frame}{More types -- streams}

\begin{center}

  $\infrule{\typing{s}{\AxiStream{A}}}{\typing{\hd[s]}{A}}$ \quad
  $\infrule{\typing{s}{\AxiStream{A}}}{\typing{\tl[s]}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule[Stream-Intro]{\typing{a}{A} \quad \typing{f}{\Fun{A}{A}}}{\typing{\introStream{a}{f}}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule[Hd-Scons]{\typing{a}{A} \quad \typing{f}{\Fun{A}{A}}}{\computation{\hd[(\introStream{a}{f})]}{a}{A}}$

  \vspace{1em}

  $\infrule[Tl-Scons]{\typing{a}{A} \quad \typing{f}{\Fun{A}{A}}}{\computation{\tl[(\introStream{a}{f})]}{\introStream{(\app{f}{a})}{f}}{\AxiStream{A}}}$
\end{center}

\end{frame}

\begin{frame}{More types -- streams 2}

Streams do have all the congruence rules we would expect, but they don't have any uniqueness rules.

\vspace{1em}

\begin{center}

  $\infrule{\computation{s}{s'}{A}}{\computation{\hd[s]}{\hd[s']}{A}}$ \quad
  $\infrule{\computation{s}{s'}{A}}{\computation{\tl[s]}{\tl[s']}{\AxiStream{A}}}$

  \vspace{1em}

  $\infrule{\computation{a}{a'}{A} \quad \computation{f}{f'}{\Fun{A}{A}}}{\computation{\introStream{a}{f}}{\introStream{a'}{f'}}{\AxiStream{A}}}$
\end{center}

\end{frame}

\begin{frame}{More types -- streams 3}

But the real question is, how do proofs by coinduction look like?

\vspace{1em}

\begin{center}

  %$\infrule{\fullholds{\Gamma}{\assume{\Delta}{R}}{\Eq[A]{\hd{s_1}}{\hd{s_2}}} \quad \fullholds{\Gamma}{\assume{\Delta}{R}}{\subst{\subst{R}{x}{\tl[s_1]}}{y}{\tl[s_2]}}}{\holds{\Eq[\AxiStream{A}]{s_1}{s_2}}}$
\end{center}

\end{frame}

\section{Additional features}

\begin{frame}{Additional features -- intro}

What other features might we add to our language? Let's find out.

\end{frame}

\begin{frame}{Additional features -- definitions in context}

We can change the definition of typing contexts to allow putting definitions in them. This can be handy for expressing let bindings and also makes fully formal derivations much shorter. However, it also requires adding a new judgement, the well-formed context judgement, because we want to allow adding only well-typed definitions to the context. We must also remember to include these definitions in computational equality.

$\Gamma ::= \emptytypingctx \pipe \extend{\Gamma}{x}{A} \pipe \extenddef{\Gamma}{x}{A}{e}$

\vspace{1em}

\begin{center}
  $\infrule[Ctx-Def]{\tyctx{\Gamma} \quad \typing{e}{A} \quad \sidecond{x \notin \Gamma}}{\tyctx{\extenddef{\Gamma}{x}{A}{e}}}$

  \vspace{1em}

  $\infrule[Comp-Ctx-Def]{\tyctx{\extenddef{\Gamma}{x}{A}{e}}}{\fullcomputation{\extenddef{\Gamma}{x}{A}{e}}{x}{e}{A}}$
\end{center}

\end{frame}

\newcommand{\letin}[3]{\texttt{let}\ #1 = #2\ \texttt{in}\ #3}

\begin{frame}{Additional features -- let bindings}

\begin{center}
  $\infrule[Let]{\typing{e_1}{A} \quad \fulltyping{\extend{\Gamma}{x}{A}}{e_2}{B}}{\typing{\letin{x}{e_1}{e_2}}{B}}$

  \vspace{1em}

  $\infrule[Let-Comp]{\typing{\letin{x}{e_1}{e_2}}{A}}{\computation{\letin{x}{e_1}{e_2}}{\subst{e_2}{x}{e_1}}{A}}$

  \vspace{1em}

  $\infrule[Let-Congr]{\computation{e_1}{e_1'}{A} \quad \computation{e_2}{e_2'}{B}}{\computation{\letin{x}{e_1}{e_2}}{\letin{x}{e_1'}{e_2'}}{B}}$
\end{center}

If definitions from the previous slide are available, we might modify the computation rule to make use of it.

\begin{center}
  $\infrule[Let-Comp-Def]{\fullcomputation{\extenddef{\Gamma}{x}{A}{e_1}}{e_2}{e_2'}{B}}{\computation{\letin{x}{e_1}{e_2}}{e_2'}{B}}$
\end{center}

\end{frame}

\newcommand{\annot}[2]{(#1 : #2)}

\begin{frame}{Additional features -- type annotations}

\begin{center}
  $\infrule[Annot]{\typing{e}{A}}{\typing{\annot{e}{A}}{A}}$

  \vspace{1em}

  $\infrule[Comp-Annot]{\typing{e}{A}}{\computation{\annot{e}{A}}{e}{A}}$
\end{center}

\end{frame}

\newcommand{\recordtype}[1]{\{#1\}}
\newcommand{\recordtypes}[4]{\recordtype{#1_{#3} : #2_{#3}}_{#3 \in #4}}
\newcommand{\record}[1]{\{#1\}}
\newcommand{\records}[4]{\record{#1_{#3} := #2_{#3}}_{#3 \in #4}}
\newcommand{\field}[2]{#1 := #2}
\newcommand{\fields}[3]{#1_{#3} := #2_{#3}}
\newcommand{\proj}[2]{#2.#1}
\newcommand{\ctype}[2]{#1 : #2}

\begin{frame}{Additional features -- record types}

\begin{center}
  $\infrule[Record-Intro]{\forall i \in I. \quad \typing{e_i}{A_i}}{\typing{\records{\ell}{e}{i}{I}}{\recordtypes{\ell}{A}{i}{I}}}$

  \vspace{1em}

  $\infrule[Record-Elim]{\typing{e}{\recordtypes{\ell}{A}{i}{I}} \quad \sidecond{j \in I}}{\typing{\proj{\ell_j}{e}}{A_j}}$

  \vspace{1em}

  $\infrule[Record-Comp]{\typing{\records{\ell}{e}{i}{I}}{\recordtypes{\ell}{A}{i}{I}} \quad \sidecond{j \in I}}{\computation{\proj{\ell_j}{\records{\ell}{e}{i}{I}}}{e_j}{A_j}}$

  \vspace{1em}

  $\infrule[Record-Uniq]{\typing{r}{\recordtypes{\ell}{A}{i}{I}}}{\computation{r}{\records{\ell}{\proj{\ell}{r}}{i}{I}}{\recordtypes{\ell}{A}{i}{I}}}$
\end{center}

\end{frame}

\newcommand{\varianttype}[1]{\left[#1\right]}
\newcommand{\varianttypes}[4]{\varianttype{#1_{#3} : #2_{#3}}_{#3 \in #4}}
\newcommand{\vcase}[2]{\texttt{vcase}\ #1\ \texttt{of}\ #2}

\begin{frame}{Additional features -- variant types}

\begin{center}
  $\infrule[Variant-Intro]{\typing{e}{A_j} \quad \sidecond{j \in I}}{\typing{\app{c_j}{e}}{\varianttypes{c}{A}{i}{I}}}$

  \vspace{1em}

  $\infrule[Variant-Elim]{\typing{e}{\varianttypes{c}{A}{i}{I}} \quad \typing{r}{\recordtypes{c}{\Fun{A_i}{B}}{i}{I}}}{\typing{\vcase{e}{r}}{B}}$

  \vspace{1em}

  $\infrule[Variant-Comp]{\typing{e}{A_j} \quad \typing{r}{\recordtypes{c}{\Fun{A_i}{B}}{i}{I}} \quad \sidecond{j \in I}}{\computation{\vcase{(\app{c_j}{e})}{r}}{\app{\proj{c_j}{r}}{e}}{B}}$

  \vspace{1em}

  $\infrule[Variant-Congr-I]{\computation{e}{e'}{A_j} \quad \sidecond{j \in I}}{\computation{\app{c_j}{e}}{\app{c_j}{e'}}{\varianttypes{c}{A}{i}{I}}}$

  \vspace{1em}

  $\infrule[Variant-Congr-E]{\computation{e}{e'}{\varianttypes{c}{A}{i}{I}} \quad \computation{r}{r'}{\recordtypes{c}{\Fun{A_i}{B}}{i}{I}}}{\computation{\vcase{e}{r}}{\vcase{e'}{r'}}{B}}$
\end{center}

\end{frame}

\newcommand{\validtype}[2]{#1 \vdash #2\ \texttt{type}}
\newcommand{\fulltype}[2]{#1 \vdash #2\ \texttt{type}}
\newcommand{\type}[1]{\fulltype{\Gamma}{#1}}

\begin{frame}{Additional features -- setup for refinement types}

For a moment, let's say that types can depend on propositions. This means that we have a well-formed type judgement which depends both on the typing context. We need to modify the valid context judgement to take this into account.

\vspace{1em}

\begin{center}
  $\infrule[Ctx-Extend]{\tyctx{\Gamma} \quad \validtype{\Gamma}{A} \quad \sidecond{x \notin \Gamma}}{\tyctx{\extend{\Gamma}{x}{A}}}$
\end{center}

With such a setup, we can express refinement types, i.e. a kind of a subset of a given type for which some proposition holds.

\end{frame}

\newcommand{\refinement}[3]{\{#1 : #2\ |\ #3\}}
\newcommand{\refine}[1]{\texttt{refine}\ #1}
\newcommand{\unrefine}[1]{\texttt{unrefine}\ #1}

\begin{frame}{Additional features -- refinement types}

\begin{center}
  $\infrule[Refinement-Form]{\type{A} \quad \prop{\extend{\Gamma}{x}{A}}{P}}{\type{\refinement{x}{A}{P}}}$

  \vspace{1em}

  $\infrule[Refinement-Intro]{\fulltyping{\Gamma \pipe \Delta}{e}{A} \quad \holds{P}}{\fulltyping{\Gamma \pipe \Delta}{\refine{e}}{\refinement{x}{A}{P}}}$

  \vspace{1em}

  $\infrule[Refinement-Elim]{\fulltyping{\Gamma \pipe \Delta}{e}{\refinement{x}{A}{P}}}{\fulltyping{\Gamma \pipe \Delta}{\unrefine{e}}{A}}$

  \vspace{1em}

  $\infrule[Refinement-Ind]{\fullholds{\extend{\Gamma}{e}{A}}{\Delta}{\subst{P}{x}{\refine{e}}}}{\holds{\All{x}{\refinement{y}{A}{P}}{P}}}$

  \vspace{1em}

  $\infrule[Refinement-Comp]{\fulltyping{\Gamma \pipe \Delta}{e}{A} \quad \holds{P}}{\computation{\unrefine{(\refine{e})}}{e}{A}}$

  \vspace{1em}

  $\infrule[Refinement-Uniq]{\fulltyping{\Gamma \pipe \Delta}{e}{\refinement{x}{A}{P}}}{\computation{e}{\refine{(\unrefine{e})}}{\refinement{x}{A}{P}}}$
\end{center}

\end{frame}

\newcommand{\quotient}[2]{#1\ \texttt{\textbackslash\textbackslash}\ #2}
\newcommand{\qin}[1]{\texttt{qin}\ #1}
\newcommand{\qout}[2]{\texttt{qout}\ #1\ #2}

\begin{frame}{Additional features -- quotients}

\begin{center}
  $\infrule[Quotient-Form]{\type{A} \quad \prop{\extend{\extend{\Gamma}{x}{A}}{y}{A}}{R} \quad \texttt{Equivalence}\ R}{\type{\quotient{A}{R}}}$

  \vspace{1em}

  $\infrule[Quotient-Intro]{\fulltyping{\Gamma \pipe \Delta}{e}{A} \quad \prop{\extend{\extend{\Gamma}{x}{A}}{y}{A}}{R} \quad \texttt{Equivalence}\ R}{\fulltyping{\Gamma \pipe \Delta}{\qin{e}}{\quotient{A}{R}}}$

  \vspace{1em}

  $\infrule[Quotient-Elim]{\fulltyping{\Gamma \pipe \Delta}{e}{\quotient{A}{R}} \quad \fulltyping{\Gamma \pipe \Delta}{f}{\Fun{A}{B}} \quad f\ \texttt{preserves}\ R}{\fulltyping{\Gamma \pipe \Delta}{\qout{f}{e}}{B}}$

  \vspace{1em}

  $\infrule[Quotient-Comp]{\fulltyping{\Gamma \pipe \Delta}{e}{A} \quad \fulltyping{\Gamma \pipe \Delta}{f}{\Fun{A}{B}} \quad f\ \texttt{preserves}\ R}{\computation{\qout{f}{(\qin{e})}}{\app{f}{e}}{B}}$
\end{center}

Where ``preserves'' is the judgement $\holds{\All{x}{A}{\All{y}{A}{\Impl{\app{\app{R}{x}}{y}}{\Eq[B]{\app{f}{x}}{\app{f}{y}}}}}}$
\end{frame}

\newcommand{\subtype}[2]{#1 <: #2}

\begin{frame}{Additional features -- more}

\begin{itemize}
  \item Subtyping -- some types are now in a subtyping relation $\subtype{A}{B}$ and an $a : A$ can be used in every place where a term of type $B$ is expected.
  \item Parametric polymorphism -- a new type former $\forall \alpha. A$. It can be either explicit (need to manage the type arguments manually) or implicit (type arguments are inferred). The implicit approach is the most common, but it's also harder to implement.
  \item Algebraic data types -- adding them in a clean manner is a bit complicated, because we either need to deal with general recursion or manage a plethora of checks, like coverage and termination.
  \item Module system -- this will be a bit harder to model, but we could borrow it from ML and OCaml.
\end{itemize}

\end{frame}

\begin{frame}{Additional features -- alternative presentations}

\begin{itemize}
  \item The system could be presented using a reduction relation which would cover the ``directed'' part of computational equality.
  \item The type system could be presented in a more algorithmic way, which is more amenable to being treated as a reference implementation.
  \item Is an explicit definition of substitution needed, or nobody cares?
\end{itemize}

\end{frame}

\end{document}