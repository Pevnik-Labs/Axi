// The syntax of quantifiers over types is as follows.
// Note that, by convention, type variables start with upper case letters.
// P, Q ::= ... | forall {A}, P | exists {A}, P

// To prove a proposition of the form `forall {A}, P`, we use `pick-any`.
// This is contrary to the programming layer, which lacks type abstraction.
// Note that the braces are mandatory and match the syntax used in the
// programming layer.
theorem forall-type-intro-example :
  forall {A}, forall x : A, x === x
proof
  pick-any A
  pick-any x
  refl
qed

// We don't need to write the `forall`s and the `pick-any`s separately.
theorem forall-type-intro-example' :
  forall {A} (x : A), x === x
proof
  pick-any A x
  refl
qed

// In proofterm style, the above proof looks as follows.
theorem forall-type-intro-example-term-style :
  forall {A} (x : A), x === x =
  pick-any A x in refl

// We eliminate the universal quantifier using `instantiate`, just like for
// the first-order universal quantifier.
theorem forall-type-elim-example :
  (forall {A} (x : A), x === x) --> forall n : Nat, n === n
proof
  assume (f = _)
  instantiate f with Nat
qed

// The syntax for the existential quantifier over types is `exists {A}, ...`.
// To prove a proposition of this form, we use `exists`.
theorem exists-type-intro-example : exists {A}, forall x : A, x === x
proof
  exists Nat
  pick-any x
  refl
qed

// The example will be silly, let's declare `R` to be a proposition.
declaration R : Prop

// The existential quantifier is eliminated with `pick-witness`.
// In our silly example, we prove that if the proposition `R` holds for
// some type, then it just holds.
theorem exists-type-elim-example : (exists {A}, R) --> R
proof
  assume (ex = _)
  pick-witness A for ex
  assumption
qed