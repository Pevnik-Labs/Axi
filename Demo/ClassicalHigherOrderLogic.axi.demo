// Higher-order classical logic.

injective (A B : Type) (f : A -> B) : Prop :=
  forall x y : A, f x = f y --> x = y

surjective (A B : Type) (f : A -> B) : Prop :=
  forall y : B, exists x : A, f x = y

bijective (A B : Type) (f : A -> B) : Prop :=
  surjective A B f /\ injective A B f

has-inverse (A B : Type) (f : A -> B) : Prop :=
  exists g : B -> A, (forall a : A, g (f a) = a) /\ (forall b : B, f (g b) = b)

theorem bijective-from-has-inverse :
  forall (A B : Type) (f : A -> B),
    has-inverse A B f --> bijective A B f :=
  pick-any-type A B
  pick-any f
  assume (exists (g : B -> A) such-that (both (gf := _) (fg := _)))
  both
  - unfold surjective             // `unfold` replaces a definition with its body in the goal
    pick-any (b : B)
    exists (g b)
    instantiate fg with b
  - unfold injective
    pick-any (x y : A)
    assume (eq := f x = f y)
    chaining= x
      = g (f x)   by (rewrite <-(instantiate gf with x) in refl) // Note that we need `x = g (f x)` whereas `gf` gives `g (f x) = x`, so we need to turn
      = g (f y)   by eq
      = y         by rewrite (instantiate gf with y)

// Let's allow eliminating propositions into types... as our way of supporting classical reasoning.
theorem has-inverse-from-bijective :
  forall (A B : Type) (f : A -> B),
    bijective A B f --> has-inverse A B f :=
  pick-any-type A B
  pick-any f
  assume (both (sur := _) (inj := _))
  exists
  - // g : B -> A
    fun b : B =>
    pick-witness a for (instantiate sur with b)
    a
  - both
    - pick-any (a' : A)                               // g (f a') = a'
      unfold g                                        // (fun b => pick-witness a for (instantiate sur with b) in a) (f a') = a'
      simpl                                           // pick-witness a for (instantiate sur with (f a')) in a = a'
      pick-witness a for (instantiate sur with (f a')) // a = a', but we now have a hypothesis f a = f a'
      modus-ponens (instantiate inj with a a')         // f a = f a'
      assumption
    - pick-any (b : B)                                // f (g b) = b
      unfold g                                        // f ((fun (b : B) => pick-witness a for (instantiate sur with b) in a) b) = b
      simpl                                           // f (pick-witness a for (instantiate sur with b) in a) = b
      pick-witness a for (instantiate sur with b)      // f a = b, but we now have a hypothesis f a = b
      assumption

// We can now prove the Axiom of Choice.
theorem choice :
  forall (A B : Type) (R : A -> B -> Prop),
    (forall a : A, exists b : B, R a b) -->
      exists f : A -> B, forall a : A, R a (f a) :=
  pick-any-type A B
  pick-any R                                          // Let Γ := A B : Type, R : A -> B -> Prop, (forall a : A, exists b : B, R a b)
  assume (allex := _)                                 // Γ |- exists f : A -> B, forall a : A, R a (f a)
  exists                                              // Γ |- ?f : A -> B, Γ |- forall a : A, R a (?f a)
  - fun (a : A) =>                                    // Γ, a : A |- B
    pick-witness b for (instantiate allex with a)      // Γ, a : A, b : B, R a b |- B
    b
  - pick-any (a : A)                                  // Γ, a : A |- R a (f a)
    unfold f                                          // Γ, a : A |- R a ((fun (a : A) => pick-witness b for (instantiate allex with a) in b) a)
    simpl                                             // Γ, a : A |- R a (pick-witness b for (instantiate allex with a) in b)
    pick-witness b for (instantiate allex with a)      // Γ, a : A, b : B, R a b |- R a b
    assumption