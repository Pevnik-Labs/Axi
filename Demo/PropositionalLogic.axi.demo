// The syntax of propositions is as follows:
// P, Q ::= True | False | P --> Q | P /\ Q | P \/ Q | P <--> Q

// We declare some propositions that we will use in the rest of this file.
declaration P Q R : Prop

// "P implies Q" is written as `P --> Q`.
// `assume p : P in q` proves `P --> Q` provided that `q` proves `Q`
// in the context extended with `p : P`, i.e. assuming `P` is true.
// In other words, `assume` is implication introduction.
theorem impl-refl-term-style : P --> P =
  assume p : P in p

// The above proof was written in proofterm style, like in DPLs/Athena,
// but we can also write proofs in tactic style, like in Coq or Lean.
// Moreover, the tactic style directly corresponds to the proofterm style,
// unlike in Coq or Lean. The mechanism is as follows: if we have a proofterm
// that takes one argument, like `tactic arg`, we can instead write it as a block
// ```
// tactic
// arg
// ```
// If the second argument is preceded by a keyword, like `in` or `by`, we can
// omit the keyword. Note that the proofterm doesn't need to be unary - it
// just needs to be applied enough so that only the last argument is missing.
// Also note that in tactic style, proofs appear in blocks delimited by the
// keywords `proof` and `qed`, and there is no `=` after the theorem statement.
theorem impl-refl : P --> P
proof
  assume p : P
  p
qed

// Let's see another example. In tactic style:
theorem weakening : P --> Q --> P
proof
  assume p : P
  assume q : Q
  p
qed

// In proofterm style, the above proof looks as follows.
theorem weakening-term-style : P --> Q --> P =
  assume p : P in
    assume q : Q in
      p

// When two or more `assume`s follow each other, we can condense them into one,
// with each assumption going in separate parentheses.
theorem assume-two : P --> Q --> P
proof
  assume (p : P) (q : Q)
  p
qed

// When we `assume` the same proposition twice, we don't even need parentheses.
theorem assume-two-same : P --> P --> P
proof
  assume p1 p2 : P
  p1
qed

// When we need to introduce an assumption that won't be used, we can discard
// it by writing an underscore.
theorem assume-discard : P --> Q --> P
proof
  assume (p : P) _
  p
qed

// We don't need to write down the proposition we are assuming, since it can be
// inferred from the theorem statement.
theorem assume-no-annotation : P --> Q --> P
proof
  assume p q
  p
qed

// If we want to avoid writing `assume` alltogether, we can put the premises
// before the final colon.
theorem no-assume (p : P) (q : Q) : P =
  p

// If we don't want to bother with recalling assumption names, we can say
// `assumption` instead.
theorem assumption-example : P --> Q --> P
proof
  assume p q
  assumption
qed

// `apply f e` proves `Q` provided that `f` proves `P --> Q` and `e` proves `P`.
// In other words, `apply` is implication elimination, also known as modus ponens.
theorem impl-elim : (P --> Q) --> P --> Q
proof
  assume pq p
  apply pq p
qed

// We can also use `apply` with more arguments when the implication is longer.
theorem apply-many-args : (P --> Q --> R) --> (Q --> P --> R)
proof
  assume pqr q p
  apply pqr p q
qed

// The above proof is equivalent to the more primitive one below.
theorem apply-many-args' : (P --> Q --> R) --> (Q --> P --> R)
proof
  assume pqr q p
  apply (apply pqr p) q
qed

// Just like for `assume`, `apply` can also be written in tactic style.
theorem impl-trans : (P --> Q) --> (Q --> R) --> (P --> R)
proof
  assume pq qr p
  apply qr
  apply pq
  p
qed

// When we need to use `apply` a few times in a row, we can condense it
// into a single line, with arguments separated by commas.
theorem apply-chaining : (P --> Q) --> (Q --> R) --> (P --> R)
proof
  assume pq qr p
  apply qr, pq
  p
qed

// We can chain many-argument `apply` just like the ordinary one.
theorem impl-dist : (P --> Q --> R) --> ((P --> Q) --> (P --> R))
proof
  assume (pqr : P --> Q --> R) (pq : P --> Q) p
  apply pqr p, pq
  p
qed

// The true proposition is written `True`.
// We can prove `True` with `trivial`.
// There's no `True` elimination, because it would be useless.
theorem true-intro-example : True
proof
  trivial
qed

// The false proposition is written `False`.
// `absurd e` proves any proposition `P` provided that `e` proves `False`.
// There's no way to prove `False`.
theorem false-elim-example : False --> P
proof
  assume e : False
  absurd e
qed

// The negation of `P` is written `~ P`.
// `~ P` is not a primitive, but rather an abbreviation of `P --> False`.
// Negation is therefore proved using `assume`, just like implication.
theorem not-false : ~ False
proof
  assume e
  e
qed

// Negation is eliminated with `apply`, just like implication.
// The below theorem, called `contradiction`, may also be used as an
// eliminator for negation for the purpose of readability.
theorem contradiction : ~ P --> P --> False
proof
  assume (np : ~ P) (p : P)
  apply np p
qed

// The conjunction of `P` and `Q` is written `P /\ Q`.
// Conjunction introduction is written `both`.
// `both p q` proves `P /\ Q` provided that `p` proves `P` and `q` proves `Q`.
theorem and-intro : P --> Q --> P /\ Q
proof
  assume p q
  both p q
qed

// Proofterms that are missing more than one argument can also be turned into
// tactics, but the syntax is a bit different: the tactic blcoks must be
// indented and preceded by the symbol `-`, which is called a "bullet"
// (following Coq naming).
theorem tactic-style-bullets-example : P --> Q --> P /\ Q
proof
  assume p q
  both
  - p
  - q
qed

// Alternatively, the tactics for each subgoal can be enclosed in curly braces.
theorem tactic-style-braces-example : P --> Q --> P /\ Q
proof
  assume p q
  both
  {
    p
  }
  {
    q
  }
qed

// Missing arguments can also be named and then they are provided as blocks
// labeled with the corresponding names.
theorem named-blocks-example : P --> Q --> P /\ Q
proof
  assume p q
  both ?x ?y
  ?x = p
  ?y = q
qed

// Note that these named blocks don't need to be proved in the order they
// were introduced in the proof. Below, we prove ?q first, even though we
// first introduced ?p.
theorem named-blocks-not-in-order-example : P --> Q --> P /\ Q
proof
  assume p q
  both ?x ?y
  ?y = q
  ?x = p
qed

// Conjunction elimination is `and-left` and `and-right`.
// `and-left e` proves `P` provided that `e` proves `P /\ Q`.
// `and-right e` proves `Q` provided that `e` proves `P /\ Q`.
theorem conjunction-elimination-example : P /\ Q --> P
proof
  assume pq
  and-left pq
qed

// We can also eliminate conjunction by pattern matching directly in `assume`.
theorem assume-pattern-matching : P /\ Q --> P
proof
  assume (both p q)
  p
qed

// When eliminating conjunction in this way, we can use annotations too.
theorem assume-pattern-matching-annotated : P /\ Q --> P
proof
  assume (both p q : P /\ Q)
  p
qed

// We can also annotate the variables, not just the entire pattern.
theorem assume-pattern-matching-annotated-var : P /\ Q --> P
proof
  assume (both (p : P) (q : Q))
  p
qed

// This pattern-matching elimination can be nested, of course.
// Also note that we can use partially applied `both` in tactic style.
theorem and-assoc : (P /\ Q) /\ R --> P /\ (Q /\ R)
proof
  assume (both (both p q) r)
  both p
  both q r
qed

// In proofterm style, the above proof looks as follows.
theorem and-assoc-term-style : (P /\ Q) /\ R --> P /\ (Q /\ R) =
  assume (both (both p q) r) in
    both p (both q r)

// The biconditional is written `P <--> Q`.
// `P <--> Q` is not a primitive, but an abbreviation of `(P --> Q) /\ (Q --> P)`.
// Therefore, biconditional introduction is `both`, just as for conjunction.
theorem iff-intro : (P --> Q) --> (Q --> P) --> P <--> Q
proof
  assume (pq : P --> Q) (qp : Q --> P)
  both pq qp
qed

// Biconditional elimination is `and-left` and `and-right`,
// just as for conjunction.
theorem iff-elim-l : (P <--> Q) --> (P --> Q)
proof
  assume pq : P <--> Q
  and-left pq
qed

// Similarly to conjunction, biconditionals can be eliminated by pattern
// matching directly in `assume`.
theorem iff-elim-r-pattern-matching : (P <--> Q) --> (Q --> P)
proof
  assume (both pq qp)
  qp
qed

// The disjunction of `P` and `Q` is written `P \/ Q`.
// Disjunction introduction is written `or-left` and `or-right`.
// `or-left e` proves `P \/ Q` provided that `e` proves `P`.
// `or-right e` proves `P \/ Q` provided that `e` proves `Q`.
theorem or-intro-l : P --> P \/ Q
proof
  assume p
  or-left p
qed

// Disjunction elimination is written `cases`.
// `cases e1 e2 e3` proves `R` provided that `e1` proves `P \/ Q`,
// `e2` proves `P --> R` and `e3` proves `Q --> R`.
theorem or-idempotent : P \/ P --> P
proof
  assume pp
  cases pp (assume p in p) (assume p in p)
qed

// Note: we don't have to prove `P --> P` inline with `assume p in p`,
// because we can use `impl-refl`, a theorem we already proved.
// Also note that theorem names can contain an apostrophe.
theorem or-idempotent' : P \/ P --> P
proof
  assume pp
  cases pp impl-refl impl-refl
qed

// Note that similarly to `both`, we can use `cases` partially
// applied in tactic style.
theorem or-elim-tactic-style : P \/ Q --> Q \/ P
proof
  assume pq
  cases pq
  - assume p
    or-right p
  - assume q
    or-left q
qed

// We can prove a lemma inline with the construct `lemma x : P by p in q`,
// where `x` is the lemma name, `P` is a proposition, `p` is its proof
// and `q` is the proof of the main theorem.
theorem lemma-example : P \/ P --> P
proof
  assume orpp
  lemma implpp : P --> P by
    assume p
    p
  cases orpp implpp implpp
qed

// In proofterm style, the above proof looks as follows.
theorem lemma-term-style : P \/ P --> P =
  assume orpp in
    lemma implpp : P --> P by
      assume p in p
    in
      cases orpp implpp implpp

// An interesting idea: maybe the best syntax for named blocks is a kind of
// reverse lemma?
theorem reverse-lemma : P \/ P --> P
proof
  assume orpp
  cases orpp ?implpp ?implpp
  lemma implpp : P --> P by
    assume p
    p
qed

// When using `lemma`, we first prove the lemma and then the main goal.
// But we can also do this in the opposite order: we first prove the
// main goal and then the lemma.
// `suffices P by e in e'` proves `Q` provided that `e` proves
// `P --> Q` and that `e'` proves `P`.
theorem suffices-example : (P --> Q) --> (Q --> R) --> P --> R
proof
  assume pq qr p
  suffices Q by apply qr
  suffices P by apply pq
  assumption
qed

// In proofterm style, the above proof looks as follows.
theorem suffices-example-term-style : (P --> Q) --> (Q --> R) --> P --> R =
  assume pq qr p in
    suffices Q by apply qr in
    suffices P by apply pq in
      assumption

// We don't need to prove the goal inline.
theorem suffices-example-no-inline : (P --> Q) --> (Q --> R) --> P --> R
proof
  assume pq qr p
  suffices Q by
    apply qr
  suffices P by
    apply pq
  assumption
qed

// If at any point in the proof it's not clear what the goal is, we can
// provide a conclusion annotation to make this obvious. The syntax is
// `proving P by e`, where `P` is a proposition and `e` proves `P`.
theorem conclusion-annotation-example : Q -> P \/ (Q \/ R)
proof
  assume q
  proving (P \/ (Q \/ R))
  or-right
  proving (Q \/ R)
  or-left
  proving Q
  assumption
qed

// In proofterm style, the above proof looks as follows.
theorem conclusion-annotation-example-term-style : Q -> P \/ (Q \/ R) =
  assume q in
    proving (P \/ (Q \/ R)) by or-right
      (proving (Q \/ R) by or-left
        (proving Q by assumption))

// Example theorems and proofs (only constructive logic).

// Currying is when we change one big conjunctive premise into a bunch
// of premises connected with implications.
theorem curry : (P /\ Q --> R) --> P --> Q --> R
proof
  assume pqr p q
  apply pqr
  both p q
qed

// Uncurrying is the reverse of currying.
theorem uncurry : (P --> Q --> R) --> (P /\ Q --> R)
proof
  assume pqr (both p q)
  apply pqr p q
qed

// Disjunction is commutative.
theorem or-comm : P \/ Q --> Q \/ P
proof
  assume pq
  cases pq
  - assume p
    or-right p
  - assume q
    or-left q
qed

// Note that `assume p in or-right p` is equivalent to just `or-right`,
// and analogously for `or-left`, so in the above proof we could have
// used those directly.
theorem or-comm' : P \/ Q --> Q \/ P
proof
  assume pq
  cases pq or-right or-left
qed

// Conjunction is commutative.
theorem and-comm : P /\ Q --> Q /\ P
proof
  assume pq
  both
  - and-right pq
  - and-left pq
qed

// The above proof gets much shorter when pattern matching
// directly in `assume`.
theorem and-comm' : P /\ Q --> Q /\ P
proof
  assume (both p q)
  both q p
qed

// `~ P \/ Q` is classically equivalent to `P --> Q`, but only one
// direction is constructive, the other being classical.
theorem impl-or-neg : ~ P \/ Q --> (P --> Q)
proof
  assume (npq : ~ P \/ Q) (p : P)
  cases npq
  - assume np : ~ P
    absurd
    apply contradiction np p
  - assume q : Q
    assumption
qed

theorem noncontradiction : ~ (P /\ ~ P)
proof
  assume (both p np)
  absurd
  apply contradiction np p
qed

theorem contraposition : (P --> Q) --> (~ Q --> ~ P)
proof
  assume pq nq p
  apply nq, pq
  assumption
qed

theorem funny-contraposition : (P --> ~ Q) --> (Q --> ~ P)
proof
  assume pnq q p
  apply pnq p q
qed

theorem iff-elim : ((P --> Q) --> (Q --> P) --> R) --> ((P <--> Q) --> R)
proof
  assume f (both pq qp)
  apply f pq qp
qed

theorem iff-not : (P <--> Q) --> (~ P <--> ~ Q)
proof
  assume (both pq qp)
  both
  - apply contraposition qp
  - apply contraposition pq
qed

theorem resolution : (P \/ Q) /\ (~ P \/ R) --> Q \/ R
proof
  assume (both pq npr)
  cases pq ?pr ?qq
  ?qq =
    assume q
    or-left q
  ?pr =
    cases npr
    - assume np
      absurd
      apply contradiction np p
    - assume r
      or-right r
qed

theorem resolution' : (P \/ Q) /\ (~ P \/ R) --> Q \/ R
proof
  assume (both np npr)
  cases pq (assume p in ?pr) (assume q in ?qq)
  ?qq =
    or-left q
  ?pr =
    cases npr
    - assume np
      absurd
      apply contradiction np p
    - assume r
      or-right r
qed

theorem not-or-intro : ~ P /\ ~ Q --> ~ (P \/ Q)
proof
  assume (both np nq) npq
  cases npq
  - assume p
    absurd
    apply contradiction np p
  - assume q
    absurd
    apply contradiction nq q
qed

theorem not-or-elim : ~ (P \/ Q) --> ~ P /\ ~ Q
proof
  assume npq : ~ (P \/ Q)
  both
  - assume p
    apply npq
    or-left
    p
  - assume q
    apply npq
    or-right
    q
qed