
type a
declaration P Q R : Prop
declaration S T : a -> a -> Prop

// The syntax of propositions is as follows:
// P, Q ::= True | False | P --> Q | P /\ Q | P \/ Q | P <--> Q

// Implication is written `-->`. The implication `P --> Q` is proved using
// `assume P in q`, where `q` is a proof of `Q`.
// Note that we claim the truth of P by writing just `P`, as in DPLs/Athena
// and contrary to type theoretical systems, where we would refer to
// something like `p : P`, a proof of P, instead.
// Note that theorem names can contain '-'.
theorem impl-refl : P --> P :=
  assume P in P

// The above proof was written in proofterm style, like in DPLs/Athena,
// but we can also write proofs in tactic style, like in Coq or Lean.
// Moreover, the tactic style directly corresponds to the proofterm style,
// unlike in Coq or Lean. The mechanism is as follows: if we have a proofterm
// that takes one argument, like `proof arg`, we can instead write it as a block
// ```
// proof
// arg
// ```
// For proofterms that bind variables, we can omit the `in`, as in the
// example below. Note that the proofterm doesn't need to be unary - it
// just needs to be applied enough so that only the last argument is missing.
// Also note that theorem names can contain an apostrophe.
theorem impl-first : P --> Q --> P :=
  assume P
  assume Q
  P

// When two or more `assume`s follow each other, we can condense them into one.
theorem assume-chaining : P --> Q --> P :=
  assume P Q
  P

// When we need to introduce an assumption that won't be used, we can discard
// it by writing an underscore.
theorem assume-discard : P --> P --> P :=
  assume P _
  P

// We can name assumptions inline with the syntax `assume (name = prop)`.
theorem assume-naming : P --> Q --> P :=
  assume (x = P) (y = Q)
  x

// If the propositions are really long to write down, we can omit them and
// mention just their new names.
theorem assume-only-naming : P --> Q --> P :=
  assume (x = _) (y = _)
  x

// If we name all assumptions without writing them out in full, the syntax
// can get a bit shorter.
theorem assume-only-naming-short : P --> Q --> P :=
  assume (x y = _)
  x

// If we don't want to bother with recalling assumption names, we can say
// `assumption` instead.
theorem assumption-example : P --> Q --> P :=
  assume P Q
  assumption

// Implication elimination is `modus-ponens`.
theorem impl-elim : (P --> Q) --> P --> Q :=
  assume (P --> Q) P
  modus-ponens (P --> Q) P

// Just like for `assume`, `modus-ponens` can also be written in tactic style.
theorem impl-trans : (P --> Q) --> (Q --> R) --> (P --> R) :=
  assume (P --> Q) (Q --> R) P
  modus-ponens (Q --> R)
  modus-ponens (P --> Q)
  P

// When we need to use `modus-ponens` a few times in a row, we can condense it
// into a single line, with arguments separated by commas.
theorem modus-ponens-chaining : (P --> Q) --> (Q --> R) --> (P --> R) :=
  assume (P --> Q) (Q --> R) P
  modus-ponens (Q --> R), (P --> Q)
  P

// True introduction. There's no True elimination, because it's useless.
theorem trivial : True :=
  true

// False elimination. There's no `False` introduction.
theorem also-trivial : False --> P :=
  assume False
  exfalso False

// Negation introduction is `suppose-absurd P in f`,
// where `f` is a proof of `False`.
theorem not-intro : (P --> False) --> ~ P :=
  assume (np = P --> False)
  suppose-absurd P
  modus-ponens np P

// Negation elimination is `absurd (~ P) P`.
theorem not-elim : ~ P --> (P --> False) :=
  assume (~ P) P
  absurd (~ P) P

// Conjunction introduction is `both`.
theorem and-intro : P --> Q --> P /\ Q :=
  assume P Q
  both P Q

// Proofterms that are missing more than one argument can also be turned into
// tactics, but the syntax is a bit different: we need to enclose the tactic
// block for each subgoal in curly braces.
theorem tactic-style-two-args-example : P --> Q --> P /\ Q :=
  assume P Q
  both
  {
    P
  }
  {
    Q
  }

// Alternatively, we can use "-" as separators. These are called "bullets",
// following Coq naming.
theorem bullets-example : P --> Q --> P /\ Q :=
  assume P Q
  both
  - P
  - Q

// Missing arguments can also be named and then they are provided as blocks
// labeled with the corresponding names.
theorem named-blocks-example : P --> Q --> P /\ Q :=
  assume P Q
  both ?p ?q
  ?p: P
  ?q: Q

// I'm not yet sure what the best syntax for bullets is.
theorem alternative-named-bullets-example : P --> Q --> P /\ Q :=
  assume P Q
  both ?p ?q
  case ?p
    P
  case ?q
    Q

// Conjunction elimination is `left-and` and `right-and`.
theorem and-elim-l : P /\ Q --> P :=
  assume (P /\ Q)
  left-and (P /\ Q)

// We can also perform conjunction elimination with pattern matching
// which is fused with `assume`.
theorem assume-pattern-matching : P /\ Q --> P :=
  assume (both P Q)
  P

// This pattern-matching elimination can be nested, of course.
// Also note that we can use partially applied `both` in tactic style.
theorem and-assoc : (P /\ Q) /\ R --> P /\ (Q /\ R) :=
  assume (both (both P Q) R)
  both P
  both Q R

// Biconditional introduction is `equivalence`.
theorem iff-intro : (P --> Q) --> (Q --> P) --> P <--> Q :=
  assume (P --> Q) (Q --> P)
  equivalence (P --> Q) (Q --> P)

// Biconditional elimination is `left-iff` and `right-iff`.
theorem iff-elim-l : (P <--> Q) --> (P --> Q) :=
  assume (P <--> Q)
  left-iff (P <--> Q)

// Similarly to conjunction, biconditionals can be eliminated by pattern
// matching fused with `assume`.
theorem iff-elim-r-pattern-matching : (P <--> Q) --> (Q --> P) :=
  assume (equivalence (P --> Q) (Q --> P))
  Q --> P

// Disjunction introduction is `left-either`.
theorem or-intro-l : P --> P \/ Q :=
  assume P
  left-either P

// Disjunction elimination is `constructive-dilemma`.
theorem or-elim : (P --> R) --> (Q --> R) --> P \/ Q --> R :=
  assume (P --> R) (Q --> R) (P \/ Q)
  constructive-dilemma (P \/ Q) (P --> R) (Q --> R)

// Note that similarly to `both`, we can use `constructive-dilemma` partially
// applied in tactic style.
theorem or-comm : P \/ Q --> Q \/ P :=
  assume (P \/ Q)
  constructive-dilemma (P \/ Q)
  {
    assume P
    right-either P
  }
  {
    assume Q
    left-either Q
  }

// Double negation elimination is `double-negation`.
theorem dn : ~ ~ P --> P :=
  assume (~ ~ P)
  double-negation (~ ~ P)

// Having seen the introduction and elimination rules, let's now take a look at
// proofterms that are unrelated to the connectives.
theorem let-example : (P <--> Q) --> (~ P <--> ~ Q) :=
  follows (contraposition = forall P Q, (P --> Q) --> (~ Q --> ~ P)) from
    assume (P --> Q) (~ Q)
    suppose-absurd P
    absurd (~ Q)
    modus-ponens (P --> Q)
    assumption
  assume (equivalence (P --> Q) (Q --> P))
  equivalence
  - modus-ponens contraposition (Q --> P)
  - modus-ponens contraposition (P --> Q)

// Some exercises.

theorem lem : P \/ ~ P :=
  double-negation
  suppose-absurd (x = ~ (P \/ ~ P))
  modus-ponens x
  right-either P
  suppose-absurd P
  modus-ponens x
  left-either (~ P) P



theorem impl-permute (P --> Q --> R) Q P : R :=
  modus-ponens (P --> Q --> R) P Q

theorem impl-dist : (P --> Q --> R) --> ((P --> Q) --> (P --> R)) :=
  assume (pqr = P --> Q --> R) (pq = P --> Q) P
  modus-ponens pqr P
  modus-ponens pq
  P

theorem curry : (P /\ Q --> R) --> P --> Q --> R :=
  assume (P /\ Q --> R) P Q
  modus-ponens (P /\ Q --> R)
  both P Q

theorem uncurry : (P --> Q --> R) --> (P /\ Q --> R) :=
  assume (P --> Q --> R) (P /\ Q)
  modus-ponens (P --> Q --> R) (left-and (P /\ Q)) (right-and (P /\ Q))

// When we want to omit more than one argument, we need to explicitly name the holes.
theorem uncurry' : (P --> Q --> R) --> (P /\ Q --> R) :=
  assume (P --> Q --> R) (P /\ Q)
  modus-ponens (P --> Q --> R) ?l ?r
  ?l: left-and (P /\ Q)
  ?r: right-and (P /\ Q)

// The subgoals' proofs don't need to be inline, they are ordinary proofs.
theorem uncurry'' : (P --> Q --> R) --> (P /\ Q --> R) :=
  assume (P --> Q --> R) (P /\ Q)
  modus-ponens (P --> Q --> R) ?l ?r
  ?l:
    left-and
    P /\ Q
  ?r:
    right-and
    P /\ Q

theorem or-comm : P \/ Q --> Q \/ P :=
  assume (P \/ Q)
  constructive-dilemma (P \/ Q) ?l ?r
  ?l: right-either Q P
  ?r: left-either P Q

/* Coq version:
Lemma or_comm_impl : P \/ Q -> Q \/ P.
Proof.
  intro.
  destruct H as [p | q].
    right. assumption.
    left. assumption.
Qed.
*/

theorem and-comm : P /\ Q --> Q /\ P :=
  assume (P /\ Q)
  both ?q ?p
  ?q: right-and (P /\ Q)
  ?p: left-and (P /\ Q)

// Patterns in assume.
theorem and-comm : P /\ Q --> Q /\ P :=
  assume (both P Q)
  both Q P

theorem and-assoc : (P /\ Q) /\ R --> P /\ (Q /\ R) :=
  assume (both (both P Q) R)
  both P (both Q R)

theorem impl-or-neg : ~ P \/ Q --> (P --> Q) :=
  assume (~ P \/ Q) P
  constructive-dilemma (~ P \/ Q)
  - absurd (~ P) P
  - assumption

theorem noncontradiction : ~ (P /\ ~ P) :=
  suppose-absurd (both P (~ P))
  absurd (~ P) P

theorem iff-not : (P <--> Q) --> (~ P <--> ~ Q) :=
  assume (equivalence (P --> Q) (Q --> P))
  equivalence
  {
    assume (~ P)
    suppose-absurd Q
    absurd (~ P)
    modus-ponens (Q --> P)
    assumption
  }
  {
    assume (~ Q)
    suppose-absurd P
    absurd (~ Q)
    modus-ponens (P --> Q)
    assumption
  }

theorem contraposition : (P --> Q) --> (~ Q --> ~ P) :=
  assume (P --> Q) (~ Q)
  suppose-absurd P
  absurd (~ Q)
  modus-ponens (P --> Q)
  assumption

theorem iff-not : (P <--> Q) --> (~ P <--> ~ Q) :=
  assume (equivalence (P --> Q) (Q --> P))
  equivalence
  { // ~ P --> ~ Q
    modus-ponens contraposition (Q --> P)
  }
  {
    modus-ponens contraposition (P --> Q)
  }

theorem iff-elim : ((P --> Q) --> (Q --> P) --> R) --> ((P <--> Q) --> R) :=
  assume (f = _) (equivalence (P --> Q) (Q --> P))
  modus-ponens f (P --> Q) (Q --> P)