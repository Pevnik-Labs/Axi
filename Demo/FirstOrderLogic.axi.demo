// The syntax of quantifiers and equality is as follows.
// P, Q ::= ... | forall x : A, P | exists x : A, P | t1 = t2

// In the rest of the file, we will need a type `A`, a term `a` of type `A`,
// and some predicates `P` and `Q` on type `A`.
type A
declaration a : A
declaration P, Q : A -> Prop

// The universal quantifier is written `forall x : A, P x`.
// Its introduction rule is `pick-any x in e` with `x` bound in `e`.
theorem forall-intro-example : forall x : A, P x \/ True :=
  pick-any x
  or-right
  trivial

// In proofterm style, the above proof looks as follows.
theorem forall-intro-example-term-style : forall x : A, P x \/ True :=
  pick-any x in
    or-right trivial

// We can omit the type annotation in the quantifiers if it can be inferred
// from the context. Below, it can be inferred from the type of `P`.
theorem forall-no-annotation-example : forall x, P x \/ True :=
  pick-any x
  or-right
  trivial

// We can also put a type annotation on the variable in `pick-any`,
// irrespective of whether it appears on the quantifier or not.
theorem pick-any-annotation : forall x, P x \/ True :=
  pick-any (x : A)
  or-right
  trivial

// The universal quantifier is eliminated with `instantiate e with x`.
theorem forall-elim-example : (forall x : A, P x) --> P a :=
  assume (forall x : A, P x)
  instantiate (forall x : A, P x) with a

// In proofterm style, the above proof looks as follows.
theorem forall-elim-example-term-style : (forall x : A, P x) --> P a :=
  assume (forall x : A, P x) in
    instantiate (forall x : A, P x) with a

// With some naming, the proof can be shortened by a lot.
theorem forall-elim-example-named : (forall x : A, P x) --> P a :=
  assume (f := _)
  instantiate f with a

// Note that it can often be inferred from context what term
// the quantifier should be instantiated with. In such a case
// we can omit the `with` clause.
theorem forall-elim-example' : (forall x : A, P x) --> P a :=
  assume (f := _)
  instantiate f

// The existential quantifier is written `exists x : A, P x`.
// Its introduction rule is `exists x such-that e` (which
// in tactic style is written simply `exists`).
theorem exists-intro-example : exists x : A, P x \/ True :=
  exists a
  or-right
  trivial

// In proofterm style, the above proof looks as follows.
theorem exists-intro-example-term-style : exists x : A, P x \/ True :=
  exists a such-that
    or-right trivial

// Similarly to the universal quantifier, the annotation on the variable
// can be omitted if it can be inferred from context, like from `P` below.
theorem exists-no-annotation-example : exists x, P x \/ True :=
  exists a
  or-right
  trivial

// We can also put a type annotation on the variable in `exists`,
// irrespective of whether it appears on the quantifier or not.
theorem exists-annotation : exists x, P x \/ True :=
  exists (a : A)
  or-right
  trivial

// The existential quantifier is eliminated with `pick-witness x for e1 in e2`,
// where x is bound in `e2`.
theorem exists-elim-example : (exists x : A, P x /\ Q x) --> exists x : A, P x :=
  assume (ex := _)
  pick-witness x for ex
  exists x
  and-left (P x /\ Q x)

// In proofterm style, the above proof looks as follows.
theorem exists-elim-example-term-style : (exists x : A, P x /\ Q x) --> exists x : A, P x :=
  assume (ex := _) in
    pick-witness x for ex in
      exists x such-that
        and-left (P x /\ Q x)

// Similarly to conjunction and biconditional, the existential quantifier can
// be eliminated by pattern matching fused with `assume`. In the proof below,
// we match not only to eliminate the existential, but also the conjunction,
// which makes the proof much shorter.
theorem exists-elim-example' : (exists x : A, P x /\ Q x) --> exists x : A, P x :=
  assume (exists x such-that (both (P x) (Q x)))
  exists x such-that (P x)

// Equality is written `t1 = t2`.
// We can prove `t = t` for any `t` using `refl`.
theorem eq-refl : forall x : A, x = x :=
  pick-any x
  refl

// In proofterm style, the above proof looks as follows.
theorem eq-refl-term-style : forall x : A, x = x :=
  pick-any x in
    refl

// Equality elimination is `rewrite e in e'`, where `e : l = r`.
// The effect is that all occurrences of `l` are replaced with `r`
// in the type of `e'`.
theorem eq-sym : forall x y : A, x = y --> y = x :=
  pick-any x y       // x y : A |- x = y --> y = x
  assume (x = y)     // x y : A, x = y |- y = x
  rewrite (x = y)    // x y : A, x = y |- y = y
  refl

// In proofterm style, the above proof looks as follows.
theorem eq-sym : forall x y : A, x = y --> y = x :=
  pick-any x y in
    assume (x = y) in
      rewrite (x = y) in
        refl

// By default, the left-hand side of the equation is replaced with
// the right-hand side. We can do the opposite by attaching the
// modifier `<-` to the equation.
theorem eq-sym' : forall x y : A, x = y --> y = x :=
  pick-any x y        // x y : A |- x = y --> y = x
  assume (x = y)      // x y : A, x = y |- y = x
  rewrite <-(x = y)   // x y : A, x = y |- x = x
  refl

// Although there is no need to do so, we can also mark the default
// left-to-right rewriting direction with the modifier `->`.
theorem eq-sym'' : forall x y : A, x = y --> y = x :=
  pick-any x y         // x y : A |- x = y --> y = x
  assume (x = y)       // x y : A, x = y |- y = x
  rewrite ->(x = y)    // x y : A, x = y |- y = y
  refl

// When we need to do two or more rewrites in a row, we can condense
// them into a single one.
theorem eq-trans : forall x y z : A, x = y --> y = z --> x = z :=
  pick-any x y z
  assume (x = y) (y = z)
  rewrite (x = y), (y = z)
  refl

// The `<-` and `->` modifiers are still valid in these bunched rewrites.
theorem rewrite-chaining-modifiers : forall x y z : A, x = y --> y = z --> x = z :=
  pick-any x y z
  assume (x = y) (y = z)
  rewrite <-(y = z), <-(x = y)
  refl

// Similarly to conjunction, biconditional and existential quantifier,
// we can eliminate equality by pattern matching fused with `assume`.
// The patterns to do this are `=->` (for left-to-right rewriting)
// and `<-=` (for right-to-left rewriting).
theorem eq-elim-pattern-matching : forall x y z : A, x = y --> y = z --> x = z :=
  pick-any x y z
  assume =-> =->
  refl

// We will finish by describing some convenience tactics for working with
// various kinds of relations (reflexive, symmetric, transitive, etc.).
// First we declare `R` to be a relation and `b`, `c` to be of type `A`.
declaration R : A -> A -> Prop
declaration b c : A

// We can use `reflexivity` to prove `R x x` when `R` is a reflexive relation.
theorem reflexivity-example : (forall x : A, R x x) --> R a a :=
  assume (rfl := _)
  reflexivity

// The above proof is desugared as follows.
theorem reflexivity-example-desugared : (forall x : A, R x x) --> R a a :=
  assume (rfl := _)
  instantiate rfl

// Optionally, `reflexivity` can take an argument.
theorem reflexivity-arg-example : (forall x : A, R x x) --> R a a :=
  assume (rfl := _)
  reflexivity a

// The above proof is desugared as follows.
theorem reflexivity-arg-example-desugared : (forall x : A, R x x) --> R a a :=
  assume (rfl := _)
  instantiate rfl with a

// There's also `symmetry`.
theorem symmetry-example :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a :=
  assume (symm := _) (R a b)
  symmetry
  assumption

// The above proof is desugared as follows.
theorem symmetry-example-desugared :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a :=
  assume (symm := _) (R a b)
  modus-ponens (instantiate symm with _ _)
  assumption

// Optionally, `symmetry` takes arguments which help the instantiation.
theorem symmetry-example :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a :=
  assume (symm := _) (R a b)
  symmetry b a
  assumption

// The above proof is desugared as follows.
theorem symmetry-example-desugared :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a :=
  assume (symm := _) (R a b)
  modus-ponens (instantiate symm with a b)
  assumption

// There's also `transitivity`. This time, the first argument is mandatory,
// because the middle element cannot be easily guessed.
theorem transitivity-example :
  (forall x y z : R x y --> R y z --> R x z) -->
    R a b --> R b c --> R a c :=
  assume (trans := _) (R a b) (R b c)
  transitivity b
  - assumption
  - assumption

// The above proof is desugared as follows.
theorem transitivity-example-desugared :
  (forall x y z : R x y --> R y z --> R x z) -->
    R a b --> R b c --> R a c :=
  assume (trans := _) (R a b) (R b c)
  modus-ponens (instantiate trans with a b c)
  - assumption
  - assumption

// Some examples.

theorem forall-impl :
  (forall x : A, P x --> Q x) --> (forall x : A, P x) --> (forall x : A, Q x) :=
  assume (pq := _) (p := _)
  pick-any x
  modus-ponens (instantiate pq with x)
  instantiate p

theorem forall-or :
  (forall x : A, P x) \/ (forall x : A, Q x) --> forall x : A, P x \/ Q x :=
  assume (orall := _)
  pick-any x
  by-cases orall
  - assume (p := _)
    or-left
    instantiate p
  - assume (q := _)
    or-left
    instantiate q

theorem forall-and :
  (forall x : A, P x /\ Q x) <--> (forall x : A, P x) /\ (forall x : A, Q x) :=
  both
  - assume (all := _)
    both
    - pick-any x
      and-left (instantiate all with x)
    - pick-any x
      and-right (instantiate all with x)
  - assume (both (p := forall x : A, P x) (q := forall x : A, Q x))
    pick-any x
    both
    - instantiate p
    - instantiate q

theorem ex-or :
  (exists x : A, P x \/ Q x) <--> (exists x : A, P x) \/ (exists x : A, Q x) :=
  both
  - assume (exists x such-that (P x \/ Q x))
    by-cases (P x \/ Q x)
    - assume (P x)
      left
      exists x
      assumption
    - assume (Q x)
      right
      exists x
      assumption
  - assume (orex := _)
    by-cases orex
    - assume (exists x such-that (P x))
      exists x
      left
      assumption
    - assume (exists x such-that (Q x))
      exists x
      right
      assumption

theorem not-exists :
  ~ (exists x : A, P x) <--> (forall x : A, ~ P x) :=
  both
  - assume (nex := _)
    pick-any x
    assume (P x)
    modus-ponens nex
    exists x
    assumption
  - assume (all := _) (exists x such-that (P x))
    modus-ponens (instantiate all with x)
    assumption

theorem not-forall : ~ (forall x : A, P x) <--> exists x : A, ~ P x :=
  both
  - assume (nall := _)
    by-contradiction (nex := ~ exists x : A, ~ P x)
    modus-ponens nall
    pick-any x
    by-contradiction (~ P x)
    modus-ponens nex
    exists x
    assumption
  - assume (exists x such-that (~ P x)) (all := _)
    modus-ponens (~ P x)
    instantiate all