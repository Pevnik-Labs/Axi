// The syntax of quantifiers and equality is as follows.
// Note that, by convention, type variables start with upper case letters.
// P, Q ::= ... | forall x : A, P | exists x : A, P | t1 === t2

// In the rest of the file, we will need a type `A`, a term `a` of type `A`,
// and some predicates `P` and `Q` on type `A`.
type A
declaration a : A
declaration P, Q : A -> Prop

// The universal quantifier is written `forall x : A, P x`.
// `pick-any x : A in e` proves `forall x : A, P x` provided that
// `e` proves `P x` in the context extended with `x : A`.
theorem forall-intro-example : forall x : A, P x \/ True
proof
  pick-any x : A
  or-right
  trivial
qed

// In proofterm style, the above proof looks as follows.
theorem forall-intro-example-term-style : forall x : A, P x \/ True =
  pick-any x : A in
    or-right trivial

// We can omit the type annotation in the quantifiers if it can be inferred
// from the context. Below, it can be inferred from the type of `P`.
theorem forall-no-annotation-example : forall x, P x \/ True
proof
  pick-any x : A
  or-right
  trivial
qed

// We can also omit the type annotation on the variable in `pick-any`,
// irrespective of whether it appears on the quantifier or not.
theorem pick-any-no-annotation : forall x, P x \/ True
proof
  pick-any x
  or-right
  trivial
qed

// `instantiate e with a` proves `P a` provided that
// `e` proves `forall x : A, P x`.
theorem forall-elim-example : (forall x : A, P x) --> P a
proof
  assume all : forall x : A, P x
  instantiate all with a
qed

// In proofterm style, the above proof looks as follows.
theorem forall-elim-example-term-style : (forall x : A, P x) --> P a =
  assume all : forall x : A, P x in
    instantiate all with a

// Note that it can often be inferred from context what term
// the quantifier should be instantiated with. In such a case
// we can omit the `with` clause. If we also omit the annotation,
// the proof gets much shorter.
theorem forall-elim-example' : (forall x : A, P x) --> P a
proof
  assume all
  instantiate all
qed

// The existential quantifier is written `exists x : A, P x`.
// `exists t such-that e` proves `exists x : A, P x`
// provided that `e` proves `P t`.
// In tactic style, it is written simply `exists`.
theorem exists-intro-example : exists x : A, P x \/ True
proof
  exists a
  or-right
  trivial
qed

// In proofterm style, the above proof looks as follows.
theorem exists-intro-example-term-style : exists x : A, P x \/ True =
  exists a such-that
    or-right trivial

// Similarly to the universal quantifier, the annotation on the variable
// can be omitted if it can be inferred from context, like from `P` below.
theorem exists-no-annotation-example : exists x, P x \/ True
proof
  exists a
  or-right
  trivial
qed

// We can also put a type annotation on the term in `exists`,
// irrespective of whether it appears on the quantifier or not.
theorem exists-annotation : exists x, P x \/ True
proof
  exists a : A
  or-right
  trivial
qed

// `pick-witness x p for e1 in e2` proves `Q` provided that
// `e1` proves `exists x : A, P x` and that
// `e2` proves `Q` in the context extended with `x : A` and `p : P x`.
theorem exists-elim-example : (exists x : A, P x /\ Q x) --> exists x : A, P x
proof
  assume ex : exists x : A, P x /\ Q x
  pick-witness x pq for ex
  exists x
  and-left pq
qed

// In proofterm style, the above proof looks as follows.
theorem exists-elim-example-term-style : (exists x : A, P x /\ Q x) --> exists x : A, P x =
  assume ex : exists x : A, P x /\ Q x in
    pick-witness x pq for ex in
      exists x such-that
        and-left pq

// Similarly to conjunction and biconditional, the existential quantifier can
// be eliminated by pattern matching fused with `assume`. In the proof below,
// we match not only to eliminate the existential, but also the conjunction,
// which makes the proof much shorter.
theorem exists-elim-example' : (exists x : A, P x /\ Q x) --> exists x : A, P x
proof
  assume (exists x such-that both p q)
  exists x such-that p
qed

// Equality is written `t1 === t2`.
// We can prove `t === t` for any `t` using `refl`.
theorem eq-refl : forall x : A, x === x
proof
  pick-any x
  refl
qed

// In proofterm style, the above proof looks as follows.
// Note that difference between the single `=` and the
// triple `===`: the first is just a symbol used when
// defining things (a term style proof in this case),
// and the second one is used to form a proposition that
// expresses the equality of two terms.
theorem eq-refl-term-style : forall x : A, x === x =
  pick-any x in
    refl

// Equality elimination is `rewrite e1 in e2`.
// `rewrite e1 in e2` proves `P l` provided that
// `e1` proves `l === r` and that `e2` proves `P r`.
theorem eq-sym : forall x y : A, x === y --> y === x
proof
  pick-any x y         // x y : A |- x === y --> y === x
  assume eq : x === y  // x y : A, eq : x === y |- y === x
  rewrite eq           // x y : A, eq : x === y |- y === y
  refl
qed

// In proofterm style, the above proof looks as follows.
theorem eq-sym-term-style : forall x y : A, x === y --> y === x =
  pick-any x y in
    assume eq : x === y in
      rewrite eq in
        refl

// By default, the left-hand side of the equation is replaced with
// the right-hand side. We can do the opposite by attaching the
// modifier `<-` to the equation.
theorem eq-sym' : forall x y : A, x === y --> y === x
proof
  pick-any x y         // x y : A |- x === y --> y === x
  assume eq : x === y  // x y : A, eq : x === y |- y === x
  rewrite <-eq         // x y : A, eq : x === y |- x === x
  refl
qed

// Although there is no need to do so, we can also mark the default
// left-to-right rewriting direction with the modifier `->`.
theorem eq-sym'' : forall x y : A, x === y --> y === x
proof
  pick-any x y         // x y : A |- x === y --> y === x
  assume eq : x === y  // x y : A, eq : x === y |- y === x
  rewrite ->eq         // x y : A, eq : x === y |- y === y
  refl
qed

// When we need to do two or more rewrites in a row, we can condense
// them into a single one.
theorem eq-trans : forall x y z : A, x === y --> y === z --> x === z
proof
  pick-any x y z
  assume (xy : x === y) (yz : y === z)
  rewrite xy, yz
  refl
qed

// The `<-` and `->` modifiers are still valid in these bunched rewrites.
theorem rewrite-modifiers :
  forall x y z : A, x === y --> y === z --> x === z
proof
  pick-any x y z
  assume (xy : x === y) (yz : y === z)
  rewrite <-xy, <-yz
  refl
qed

// Similarly to conjunction, biconditional and existential quantifier,
// we can eliminate equality by pattern matching fused with `assume`.
// The patterns to do this are `===>` (for left-to-right rewriting)
// and `<===` (for right-to-left rewriting).
theorem eq-elim-pattern-matching :
  forall x y z : A, x === y --> y === z --> x === z
proof
  pick-any x y z
  assume ===> ===>
  refl
qed

// We will finish by describing some convenience tactics for working with
// various kinds of relations (reflexive, symmetric, transitive, etc.).
// First we declare `R` to be a relation and `b`, `c` to be of type `A`.
declaration R : A -> A -> Prop
declaration b c : A

// We can use `reflexivity` to prove `R x x` when `R` is a reflexive relation.
theorem reflexivity-example : (forall x : A, R x x) --> R a a
proof
  assume rfl
  reflexivity
qed

// The above proof is desugared as follows.
theorem reflexivity-example-desugared : (forall x : A, R x x) --> R a a
proof
  assume rfl
  instantiate rfl
qed

// Optionally, `reflexivity` can take an argument.
theorem reflexivity-arg-example : (forall x : A, R x x) --> R a a
proof
  assume rfl
  reflexivity a
qed

// The above proof is desugared as follows.
theorem reflexivity-arg-example-desugared : (forall x : A, R x x) --> R a a
proof
  assume rfl
  instantiate rfl with a
qed

// There's also `symmetry`.
// `symmetry e` proves `R b a` provided that `e` proves `R a b`.
theorem symmetry-example :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a
proof
  assume sym (ab : R a b)
  symmetry
  assumption
qed

// The above proof is desugared as follows.
theorem symmetry-example-desugared :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a
proof
  assume sym (ab : R a b)
  apply (instantiate sym with _ _)
  assumption
qed

// Optionally, `symmetry` takes arguments which help the instantiation.
theorem symmetry-example :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a
proof
  assume sym (ab : R a b)
  symmetry b a
  assumption
qed

// The above proof is desugared as follows.
theorem symmetry-example-desugared :
  (forall x y : A, R x y --> R y x) --> R a b --> R b a
proof
  assume sym (ab : R a b)
  apply (instantiate symm with a b)
  assumption
qed

// There's also `transitivity`. This time, the first argument is mandatory,
// because the middle element cannot be easily guessed.
theorem transitivity-example :
  (forall x y z : R x y --> R y z --> R x z) -->
    R a b --> R b c --> R a c
proof
  assume trans (ab : R a b) (bc : R b c)
  transitivity b
  - assumption
  - assumption
qed

// The above proof is desugared as follows.
theorem transitivity-example-desugared :
  (forall x y z : R x y --> R y z --> R x z) -->
    R a b --> R b c --> R a c
proof
  assume trans (ab : R a b) (bc : R b c)
  apply (instantiate trans with a b c)
  - assumption
  - assumption
qed

// Some examples.

theorem forall-impl :
  (forall x : A, P x --> Q x) --> (forall x : A, P x) --> (forall x : A, Q x)
proof
  assume pq p
  pick-any x
  apply (instantiate pq with x)
  instantiate p
qed

theorem forall-or :
  (forall x : A, P x) \/ (forall x : A, Q x) --> forall x : A, P x \/ Q x
proof
  assume orall
  pick-any x
  cases orall
  - assume allp
    or-left
    instantiate allp
  - assume allq
    or-right
    instantiate allq
qed

theorem forall-and :
  (forall x : A, P x /\ Q x) <--> (forall x : A, P x) /\ (forall x : A, Q x)
proof
  both
  - assume all
    both
    - pick-any x
      and-left (instantiate all with x)
    - pick-any x
      and-right (instantiate all with x)
  - assume (both allp allq)
    pick-any x
    both
    - instantiate allp
    - instantiate allq
qed

theorem ex-or :
  (exists x : A, P x \/ Q x) <--> (exists x : A, P x) \/ (exists x : A, Q x)
proof
  both
  - assume (exists x such-that exor)
    cases exor
    - assume p
      or-left
      exists x
      assumption
    - assume q
      or-right
      exists x
      assumption
  - assume orex
    cases orex
    - assume (exists x such-that p)
      exists x
      or-left
      assumption
    - assume (exists x such-that q)
      exists x
      or-right
      assumption
qed

theorem not-exists :
  ~ (exists x : A, P x) <--> (forall x : A, ~ P x)
proof
  both
  - assume nex
    pick-any x
    assume p
    apply nex
    exists x
    assumption
  - assume allnp (exists x such-that p)
    apply (instantiate allnp with x)
    assumption
qed

theorem not-forall : ~ (forall x : A, P x) <--> exists x : A, ~ P x
proof
  both
  - assume nall
    by-contradiction nexn : ~ exists x : A, ~ P x
    apply nall
    pick-any x
    by-contradiction np : ~ P x
    apply nexn
    exists x
    assumption
  - assume (exists x such-that np) all
    apply np
    instantiate all
qed