// The syntax of quantifiers over types is as follows.
// P, Q ::= ... | forall-type A, P | exists-type A, P

theorem forall-type-intro-example : forall-type A, forall x : A, x = x :=
  pick-any-type A
  pick-any x
  refl

theorem forall-type-elim-example :
  (forall-type A, forall x : A, x = x) --> forall n : Nat, n = n :=
  assume (f := _)
  instantiate-type f Nat

theorem exists-type-intro-example : exists-type A, forall x : A, x = x :=
  exists-type Nat
  pick-any x
  refl

theorem exists-type-elim-example : exists-type A, ...



// Higher-order logic is added to the system in the following way.
// We extend the type language with a new type, called `Prop`, which serves
// as the type of propositions. Functions into `Prop` are identified with
// predicates and relations.
// There's a subtlety, however. These new types exist only in the logical
// part of the language, for example when writing type annotations in quantifiers.
// In the programming part of the language, these types are not present, so for
// example it is not possible to implement a program that takes a propositions as
// an argument.

theorem forall-prop-intro-example : forall P : Prop, P --> P :=
  pick-any P
  assume P
  assumption

theorem forall-prop-intro-example' : forall P Q : Prop, P --> P \/ Q :=
  pick-any P Q
  assume P
  or-left
  assumption

theorem forall-prop-elim-example : (forall P : Prop, P) --> False :=
  assume (all := _)
  instantiate all with False

// Defining logical connectives using higher-order quantification.

// We can define our custom equivalent of `False` as a proposition which
// says that all propositions hold.
myfalse : Prop := forall R : Prop, R

// `myfalse` is equivalent to `False`.
theorem myfalse-spec : myfalse <--> False :=
  both
  - assume (mf := _)
    instantiate mf with False
  - assume False
    absurd False

// The impredicative encoding of `True`.
mytrue : Prop := foral R : Prop, R --> R

theorem mytrue-spec : mytrue <--> True :=
  both
  - assume _
    trivial
  - assume _
    pick-any R
    assume R
    assumption

// Impredicative encoding of conjunction.
myand (P Q : Prop) : Prop := forall R : Prop, (P --> Q --> R) --> R

theorem myand-spec : forall P Q : Prop, myand P Q <--> P /\ Q :=
  pick-any P Q
  both
  - assume (pq := _)
    both
    - modus-ponens (instantiate pq with P)
      assume P _
      assumption
    - modus-ponens (instantiate pq with Q)
      assume _ Q
      assumption
  - assume (both P Q)
    pick-any R
    assume (pqr := _)
    modus-ponens pqr
    - assumption
    - assumption

// Impredicative encoding of disjunction.
myor (P Q : Prop) : Prop := forall R : Prop, (P --> R) --> (Q --> R) --> R

theorem myor-spec : forall P Q : Prop, myor P Q <--> P \/ Q :=
  pick-any P Q
  both
  - assume (pq := _)
    modus-ponens (instantiate pq with (P \/ Q))
    - or-left
    - or-right
  - assume (P \/ Q)
    pick-any R
    assume (P --> R)
    assume (Q --> R)
    by-cases (P \/ Q) (P --> R) (Q --> R)

// Impredicative encoding of the existential quantifier.
myex (A : Type) (P : A -> Prop) : Prop :=
  forall R : Prop, (forall x : A, P x --> R) --> R

theorem myex-spec :
  forall-type A, forall P : A -> Prop, myex A P <--> exists x : A, P x :=
  pick-any-type A
  pick-any P
  both
  - assume (mx := _)
    modus-ponens (instantiate myex with (exists x : A, P x))
    pick-any (x : A)
    assume (P x)
    exists x
    assumption
  - assume (exists x such-that (P x))
    pick-any R
    assume (all := _)
    instantiate all with x
    assumption

// Impredicative encoding of equality.
myeq (A : Type) (x y : A) : Prop :=
  forall P : A -> Prop, P x --> P y

theorem myeq-spec :
  forall-type A, forall x y : A, myeq x y <--> x = y :=
  pick-any-type A
  pick-any (x y : A)
  both
  - assume (all := _)                                             // x = y
    modus-ponens (instantiate all with (fun (a : A) => x = a))     // x = x
    refl
  - assume =->                                                    // myeq x x
    unfold myeq                                                   // forall P : A -> Prop, P x --> P x
    pick-any (P : A -> Prop)                                      // P : A -> Prop |- P x --> P x
    assume (P x)                                                  // P : A -> Prop, P x |- P x
    assumption