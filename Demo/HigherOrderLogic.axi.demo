// The syntax of higher-order quantifiers is as follows.
// Note that `L` stands for a logical kind.
// P, Q ::= ... | forall P : L, Q | exists P : L, Q

theorem forall-prop-intro-example : forall P : Prop, P --> P
proof
  pick-any P
  assume p : P
  assumption
qed

theorem forall-prop-intro-example' : forall P Q : Prop, P --> P \/ Q
proof
  pick-any P Q
  assume p : P
  or-left
  assumption
qed

theorem forall-prop-elim-example : (forall P : Prop, P) --> False
proof
  assume all
  instantiate all with False
qed

// Defining logical connectives using higher-order quantification.

// We can define our custom equivalent of `False` as a proposition which
// says that all propositions hold.
myfalse : Prop =
  forall R : Prop, R

// `myfalse` is equivalent to `False`.
theorem myfalse-spec : myfalse <--> False
proof
  both
  - assume mf
    instantiate mf with False
  - assume e : False
    absurd e
qed

// The impredicative encoding of `True`.
mytrue : Prop =
  foral R : Prop, R --> R

theorem mytrue-spec : mytrue <--> True
proof
  both
  - assume _
    trivial
  - assume _
    pick-any R
    assume r : R
    assumption
qed

// Impredicative encoding of conjunction.
myand (P Q : Prop) : Prop =
  forall R : Prop, (P --> Q --> R) --> R

theorem myand-spec : forall P Q : Prop, myand P Q <--> P /\ Q
proof
  pick-any P Q
  both
  - assume pq : myand P Q
    both
    - apply (instantiate pq with P)
      assume p _
      assumption
    - apply (instantiate pq with Q)
      assume _ q
      assumption
  - assume (both p q)
    pick-any R
    assume pqr : P --> Q --> R
    apply pqr
    - assumption
    - assumption
qed

// Impredicative encoding of disjunction.
myor (P Q : Prop) : Prop =
  forall R : Prop, (P --> R) --> (Q --> R) --> R

theorem myor-spec : forall P Q : Prop, myor P Q <--> P \/ Q
proof
  pick-any P Q
  both
  - assume pq : myor P Q
    apply (instantiate pq with (P \/ Q))
    - or-left
    - or-right
  - assume pq : P \/ Q
    pick-any R
    assume pr : P --> R
    assume qr : Q --> R
    cases pq pr qr
qed

// Impredicative encoding of the existential quantifier.
myex {A} (P : A -> Prop) : Prop =
  forall R : Prop, (forall x : A, P x --> R) --> R

theorem myex-spec :
  forall {A} (P : A -> Prop), myex A P <--> exists x : A, P x
proof
  pick-any A P
  both
  - assume mx : myex A P
    apply (instantiate mx with (exists x : A, P x))
    pick-any x : A
    assume px : P x
    exists x
    assumption
  - assume (exists x such-that px)
    pick-any R
    assume all
    instantiate all with x
    assumption
qed

// Impredicative encoding of equality.
myeq {A} (x y : A) : Prop =
  forall P : A -> Prop, P x --> P y

theorem myeq-spec :
  forall {A} (x y : A), myeq x y <--> x === y
proof
  pick-any A (x y : A)
  both
  - assume all                                                    // x === y
    apply (instantiate all with (fun (a : A) => x === a))         // x === x
    refl
  - assume ===>                                                   // myeq x x
    unfold myeq                                                   // forall P : A -> Prop, P x --> P x
    pick-any P : A -> Prop                                        // P : A -> Prop |- P x --> P x
    assume px : P x                                               // P : A -> Prop, px : P x |- P x
    assumption
qed