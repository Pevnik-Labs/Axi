// The syntax of higher-order quantifiers is as follows.
// Note that `L` stands for a logical kind.
// P, Q ::= ... | forall P : L, Q | exists P : L, Q

theorem forall-prop-intro-example : forall P : Prop, P --> P
proof
  pick-any P
  assume P
  assumption
qed

theorem forall-prop-intro-example' : forall P Q : Prop, P --> P \/ Q
proof
  pick-any P Q
  assume P
  or-left
  assumption
qed

theorem forall-prop-elim-example : (forall P : Prop, P) --> False
proof
  assume (all = _)
  instantiate all with False
qed

// Defining logical connectives using higher-order quantification.

// We can define our custom equivalent of `False` as a proposition which
// says that all propositions hold.
myfalse : Prop = forall R : Prop, R

// `myfalse` is equivalent to `False`.
theorem myfalse-spec : myfalse <--> False
proof
  both
  - assume (mf = _)
    instantiate mf with False
  - assume False
    absurd False
qed

// The impredicative encoding of `True`.
mytrue : Prop = foral R : Prop, R --> R

theorem mytrue-spec : mytrue <--> True
proof
  both
  - assume _
    trivial
  - assume _
    pick-any R
    assume R
    assumption
qed

// Impredicative encoding of conjunction.
myand (P Q : Prop) : Prop = forall R : Prop, (P --> Q --> R) --> R

theorem myand-spec : forall P Q : Prop, myand P Q <--> P /\ Q
proof
  pick-any P Q
  both
  - assume (pq = _)
    both
    - apply (instantiate pq with P)
      assume P _
      assumption
    - apply (instantiate pq with Q)
      assume _ Q
      assumption
  - assume (both P Q)
    pick-any R
    assume (pqr = _)
    apply pqr
    - assumption
    - assumption
qed

// Impredicative encoding of disjunction.
myor (P Q : Prop) : Prop = forall R : Prop, (P --> R) --> (Q --> R) --> R

theorem myor-spec : forall P Q : Prop, myor P Q <--> P \/ Q
proof
  pick-any P Q
  both
  - assume (pq = _)
    apply (instantiate pq with (P \/ Q))
    - or-left
    - or-right
  - assume (P \/ Q)
    pick-any R
    assume (P --> R)
    assume (Q --> R)
    cases (P \/ Q) (P --> R) (Q --> R)
qed

// Impredicative encoding of the existential quantifier.
myex {A} (P : A -> Prop) : Prop =
  forall R : Prop, (forall x : A, P x --> R) --> R

theorem myex-spec :
  forall {A} (P : A -> Prop), myex A P <--> exists x : A, P x
proof
  pick-any A P
  both
  - assume (mx = _)
    apply (instantiate myex with (exists x : A, P x))
    pick-any (x : A)
    assume (P x)
    exists x
    assumption
  - assume (exists x such-that (P x))
    pick-any R
    assume (all = _)
    instantiate all with x
    assumption
qed

// Impredicative encoding of equality.
myeq {A} (x y : A) : Prop =
  forall P : A -> Prop, P x --> P y

theorem myeq-spec :
  forall {A} (x y : A), myeq x y <--> x === y
proof
  pick-any {A} (x y : A)
  both
  - assume (all = _)                                             // x === y
    apply (instantiate all with (fun (a : A) => x === a))        // x === x
    refl
  - assume =->                                                    // myeq x x
    unfold myeq                                                   // forall P : A -> Prop, P x --> P x
    pick-any (P : A -> Prop)                                      // P : A -> Prop |- P x --> P x
    assume (P x)                                                  // P : A -> Prop, P x |- P x
    assumption
qed