// The syntax of quantifiers over types is as follows.
// P, Q ::= ... | forall A : Type, P | exists A : Type, P

theorem forall-type-intro-example : forall (A : Type) (x : A), x = x
proof
  pick-any A x
  refl
qed

theorem forall-type-elim-example :
  (forall (A : Type) (x : A), x = x) --> forall n : Nat, n = n
proof
  assume (f := _)
  instantiate f Nat
qed

theorem exists-type-intro-example : exists (A : Type), forall x : A, x = x
proof
  exists Nat
  pick-any x
  refl
qed

theorem exists-type-elim-example : exists (A : Type), ...



// Higher-order logic is added to the system in the following way.
// We extend the type language with a new type, called `Prop`, which serves
// as the type of propositions. Functions into `Prop` are identified with
// predicates and relations.
// There's a subtlety, however. These new types exist only in the logical
// part of the language, for example when writing type annotations in quantifiers.
// In the programming part of the language, these types are not present, so for
// example it is not possible to implement a program that takes a propositions as
// an argument.

theorem forall-prop-intro-example : forall P : Prop, P --> P
proof
  pick-any P
  assume P
  assumption
qed

theorem forall-prop-intro-example' : forall P Q : Prop, P --> P \/ Q
proof
  pick-any P Q
  assume P
  or-left
  assumption
qed

theorem forall-prop-elim-example : (forall P : Prop, P) --> False
proof
  assume (all := _)
  instantiate all with False
qed

// Defining logical connectives using higher-order quantification.

// We can define our custom equivalent of `False` as a proposition which
// says that all propositions hold.
myfalse : Prop := forall R : Prop, R

// `myfalse` is equivalent to `False`.
theorem myfalse-spec : myfalse <--> False
proof
  both
  - assume (mf := _)
    instantiate mf with False
  - assume False
    absurd False
qed

// The impredicative encoding of `True`.
mytrue : Prop := foral R : Prop, R --> R

theorem mytrue-spec : mytrue <--> True
proof
  both
  - assume _
    trivial
  - assume _
    pick-any R
    assume R
    assumption
qed

// Impredicative encoding of conjunction.
myand (P Q : Prop) : Prop := forall R : Prop, (P --> Q --> R) --> R

theorem myand-spec : forall P Q : Prop, myand P Q <--> P /\ Q
proof
  pick-any P Q
  both
  - assume (pq := _)
    both
    - apply (instantiate pq with P)
      assume P _
      assumption
    - apply (instantiate pq with Q)
      assume _ Q
      assumption
  - assume (both P Q)
    pick-any R
    assume (pqr := _)
    apply pqr
    - assumption
    - assumption
qed

// Impredicative encoding of disjunction.
myor (P Q : Prop) : Prop := forall R : Prop, (P --> R) --> (Q --> R) --> R

theorem myor-spec : forall P Q : Prop, myor P Q <--> P \/ Q
proof
  pick-any P Q
  both
  - assume (pq := _)
    apply (instantiate pq with (P \/ Q))
    - or-left
    - or-right
  - assume (P \/ Q)
    pick-any R
    assume (P --> R)
    assume (Q --> R)
    cases (P \/ Q) (P --> R) (Q --> R)
qed

// Impredicative encoding of the existential quantifier.
myex (A : Type) (P : A -> Prop) : Prop :=
  forall R : Prop, (forall x : A, P x --> R) --> R

theorem myex-spec :
  forall (A : Type) (P : A -> Prop), myex A P <--> exists x : A, P x
proof
  pick-any A P
  both
  - assume (mx := _)
    apply (instantiate myex with (exists x : A, P x))
    pick-any (x : A)
    assume (P x)
    exists x
    assumption
  - assume (exists x such-that (P x))
    pick-any R
    assume (all := _)
    instantiate all with x
    assumption
qed

// Impredicative encoding of equality.
myeq (A : Type) (x y : A) : Prop :=
  forall P : A -> Prop, P x --> P y

theorem myeq-spec :
  forall (A : Type) (x y : A), myeq x y <--> x = y
proof
  pick-any (A : Type) (x y : A)
  both
  - assume (all := _)                                             // x = y
    apply (instantiate all with (fun (a : A) => x = a))    // x = x
    refl
  - assume =->                                                    // myeq x x
    unfold myeq                                                   // forall P : A -> Prop, P x --> P x
    pick-any (P : A -> Prop)                                      // P : A -> Prop |- P x --> P x
    assume (P x)                                                  // P : A -> Prop, P x |- P x
    assumption
qed