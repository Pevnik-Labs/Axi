// We declare some propositions that will be used in this file.
declaration P Q R S T : Prop

// When we want to prove some goal using a long chain of implications,
// we can use chaining. In the example below we showcase backward
// chaining, i.e. we start with the conclusion and then list
// a bunch of intermediate goals together with proofs (after `by`) that
// the current goal follows from them.
theorem implication-chaining-backwards :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T, P
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P  // Γ |- T  // After making all the assumptions, the goal is `T`.
  chaining<-- T                                     // Γ |- T  // We start the chain. `<--` means it's backward chaining for implication. The goal is still `T`.
    <-- S         by (S --> T)                      // Γ |- S  // The goal changes to `S` because `S` implies `T` as shown in the `by` clause.
    <-- R         by (R --> S)                      // Γ |- R
    <-- Q         by (Q --> R)                      // Γ |- Q
    <-- P         by (P --> Q)                      // Γ |- P  // After the final step, the goal that we are left with is `P`.
  assumption                                        // We now solve `P`, the goal produced by chaining.

// In proofterm style, the above proof looks as follows.
theorem implication-chaining-backwards-term-style :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P in
    chaining<-- T
      <-- S         by (S --> T)
      <-- R         by (R --> S)
      <-- Q         by (Q --> R)
      <-- P         by (P --> Q)
    in
      assumption

// The chaining gets desugared to a bunch of uses of `modus-ponens`.
theorem implication-chaining-backwards-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  modus-ponens (S --> T)
  modus-ponens (R --> S)
  modus-ponens (Q --> R)
  modus-ponens (P --> Q)
  assumption

// It's easy to see how to do the same proof without any chaining.
// It's much shorter this way, but probably also less readable.
theorem no-chaining :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  modus-ponens (S --> T), (R --> S), (Q --> R), (P --> Q)
  assumption

// The expression after `by` can be any proofterm, for example it can be `assumption`.
theorem implication-chaining-backwards-assumption :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  chaining<-- T
    <-- S         by assumption
    <-- R         by assumption
    <-- Q         by assumption
    <-- P         by assumption
  assumption

// I imagine that when we have a mildly powerful automation tactic
// akin to Coq's `auto`, let's call it `hammer`, it would be the
// default thing passed to `by`, so that the `by` could be omitted.
theorem implication-chaining-backwards-default :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  chaining<-- T
    <-- S
    <-- R
    <-- Q
    <-- P
  assumption

// There's also a different style of backwards chaining. The last time
// we introduced all assumptions into the context, used chainig to
// change the goal from `T` to `P` and then proved `P` with `assumption`.
// This time we'll use chaining to prove `P --> T` directly.
theorem implication-chaining-backwards-direct :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)    // Γ |- P --> T  // Let's assume everything EXCEPT the last `P`, so that the goal is `P --> T`.
  chaining<-- T                                     // Γ |- P --> T  // We start the chain. The goal is still `P --> T`.
    <-- S         by (S --> T)                      // Γ |- P --> S  // The goal changes to `P --> S` because `S` implies `T` as shown in the `by` clause.
    <-- R         by (R --> S)                      // Γ |- P --> R
    <-- Q         by (Q --> R)                      // Γ |- P --> Q
    <-- P         by (P --> Q)                      // In the last step we prove `P --> Q`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `impl-trans'` is
// this theorem: `forall Q R P : Prop, (Q --> R) --> (P --> Q) --> (P --> R)`
theorem implication-chaining-backwards-direct-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)
  modus-ponens (instantiate impl-trans' with S T P) (S --> T)
  modus-ponens (instantiate impl-trans' with R S P) (R --> S)
  modus-ponens (instantiate impl-trans' with Q R P) (Q --> R) (P --> Q)

// Besides backward chaining, there's also forward chaining. This time
// we start with a premise and draw intermediate conclusions from it,
// justifying each step, until we reach the goal.
theorem implication-chaining-forwards-example :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)    // Γ |- P --> T  // After making all the assumptions, the goal is `P --> T`.
  chaining--> P                                     // Γ |- P --> T  // We start the chain. `-->` means it's forward chaining for implication. The goal is still `P --> T`.
    --> Q         by (P --> Q)                      // Γ |- Q --> T  // The goal changes to `Q --> T` because `P` implies `Q` as shown in the `by` clause.
    --> R         by (Q --> R)                      // Γ |- R --> T
    --> S         by (R --> S)                      // Γ |- S --> T
    --> T         by (S --> T)                      // In the last step we prove `S --> T`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `impl-trans` is
// this theorem: `forall P Q R : Prop, (P --> Q) --> (Q --> R) --> (P --> R)`.
theorem implication-chaining-forwards-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)
  modus-ponens (instantiate impl-trans with P Q T) (P --> Q)
  modus-ponens (instantiate impl-trans with Q R T) (Q --> R)
  modus-ponens (instantiate impl-trans with R S T) (R --> S) (S --> T)

// We can also use chaining for biconditionals. The only 'mode' of chaining
// here is forward (although I think backwards would also be possible).
theorem biconditional-chaining-example :
  (P <--> Q) --> (Q <--> R) --> (R <--> S) --> (S <--> T) --> P <--> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T
  assume (P <--> Q) (Q <--> R) (R <--> S) (S <--> T)  // Γ |- P <--> T  // After making all the assumptions, the goal is `P <--> T`.
  chaining<--> P                                      // Γ |- P <--> T  // We start the chain. `<-->` means it's chaining for biconditional. The goal is still `P <--> T`.
    <--> Q        by (P <--> Q)                       // Γ |- Q <--> T  // The goal changes to `Q <--> T` because `P <--> Q` as shown in the `by` clause.
    <--> R        by (Q <--> R)                       // Γ |- R <--> T
    <--> S        by (R <--> S)                       // Γ |- S <--> T
    <--> T        by (S <--> T)                       // In the last step we prove `S <--> T`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `iff-trans` is
// this theorem: `forall P Q R : Prop, (P <--> Q) --> (Q <--> R) --> (P <--> R)`.
theorem biconditional-chaining-desugared-example :
  (P <--> Q) --> (Q <--> R) --> (R <--> S) --> (S <--> T) --> P <--> T :=
  assume (P <--> Q) (Q <--> R) (R <--> S) (S <--> T)
  modus-ponens (instantiate iff-trans with P Q T) (P <--> Q)
  modus-ponens (instantiate iff-trans with Q R T) (Q <--> R)
  modus-ponens (instantiate iff-trans with R S T) (R <--> S) (S <--> T)

// There's also chaining for equality.
theorem equational-chaining :
  forall x y z w : A, x = y --> y = z --> z = w --> x = w :=
  pick-any x y z w
  // Let Γ := x y z w : A, x = y, y = z, z = w
  assume (x = y) (y = z) (z = w)                // Γ |- x = z
  chaining= x                                   // Γ |- x = z
    = y       by (x = y)                        // Γ |- y = z
    = z       by (y = z)

// In proofterm style, the above proof looks as follows.
theorem equational-chaining-term-style :
  forall x y z : A, x = y --> y = z --> x = z :=
  pick-any x y z in
    assume (x = y) (y = z) in
      chaining x
        = y       by (x = y)
        = z       by (y = z)

// In general, a chain of the form
// ```
// chaining t
//   = t1      by e1
//   ...
//   = tn      by en
// ```
// proves `t = tn` and is a notation for `rewrite e1, ..., en`.

// Sometimes chaining can be clearer than `rewrite`.
theorem chaining-assumption : forall x y z : A, x = y --> y = z --> x = z :=
  pick-any x y z
  assume (x = y) (y = z)
  chaining x
    = y       by assumption
    = z       by assumption

// Chaining can be generalized to any transitive relation.
theorem relational-chaining-example :
  forall (A : Type), forall (R : A -> A -> Prop), forall a b c d e : A,
    (forall x y z : A, R x y --> R y z --> R x z) -->
    R a b --> R b c --> R c d --> R d e --> R a e :=
  pick-any A R a b c d e
  assume (trans ab bc cd de := _)
  chaining R a
    R b           by (R a b)
    R c           by (R b c)
    R d           by (R c d)
    R e           by (R d e)

// The above proof gets desugared to:
theorem relational-chaining-example :
  forall (A : Type), forall (R : A -> A -> Prop), forall a b c d e : A,
    (forall x y z : A, R x y --> R y z --> R x z) -->
    R a b --> R b c --> R c d --> R d e --> R a e :=
  pick-any A R a b c d e
  assume (trans ab bc cd de := _)
  modus-ponens (instantiate trans with a b e) (R a b)
  modus-ponens (instantiate trans with b c e) (R b c)
  modus-ponens (instantiate trans with c d e) (R c d) (R d e)