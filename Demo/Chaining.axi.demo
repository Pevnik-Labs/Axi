// We declare some propositions that will be used in this file.
declaration P Q R S T : Prop

// When we want to prove some goal using a long chain of implications,
// we can do it with chaining. In the example below we showcase backward
// chaining, i.e. we start with the conclusion and then list a bunch of
// intermediate goals together with proofs (after `by`) that the current
// goal follows from them.
theorem implication-chaining-backwards :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T, P
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P  // Γ |- T  // After making all the assumptions, the goal is `T`.
  chaining<-- T                                     // Γ |- T  // We start the chain. `<--` means it's backward chaining for implication. The goal is still `T`.
    <-- S         by (S --> T)                      // Γ |- S  // The goal changes to `S` because `S` implies `T`, as proven in the `by` clause.
    <-- R         by (R --> S)                      // Γ |- R
    <-- Q         by (Q --> R)                      // Γ |- Q
    <-- P         by (P --> Q)                      // Γ |- P  // After the final step, the goal that we are left with is `P`.
  assumption                                        // We now solve `P`, the goal produced by chaining.

// In proofterm style, the above proof looks as follows.
theorem implication-chaining-backwards-term-style :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P in
    chaining<-- T
      <-- S         by (S --> T)
      <-- R         by (R --> S)
      <-- Q         by (Q --> R)
      <-- P         by (P --> Q)
    in
      assumption

// The chaining gets desugared to a bunch of uses of `apply`.
theorem implication-chaining-backwards-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  apply (S --> T)
  apply (R --> S)
  apply (Q --> R)
  apply (P --> Q)
  assumption

// The expression after `by` can be any proofterm, for example it can be `assumption`.
theorem implication-chaining-backwards-assumption :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  chaining<-- T
    <-- S         by assumption
    <-- R         by assumption
    <-- Q         by assumption
    <-- P         by assumption
  assumption

// I imagine that when we have a mildly powerful automation tactic
// akin to Coq's `auto`, it would be the default thing passed to `by`,
// so that the `by` could be omitted.
theorem implication-chaining-backwards-default :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T) P
  chaining<-- T
    <-- S
    <-- R
    <-- Q
    <-- P
  assumption

// There's also a different style of backwards chaining. The last time
// we introduced all assumptions into the context, used chaining to
// change the goal from `T` to `P` and then proved `P` with `assumption`.
// This time we'll use chaining to prove `P --> T` directly.
theorem implication-chaining-backwards-direct :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)  // Γ |- P --> T  // Let's assume everything EXCEPT the last `P`, so that the goal is `P --> T`.
  chaining<-- T                                   // Γ |- P --> T  // We start the chain. The goal is still `P --> T`.
    <-- S         by (S --> T)                    // Γ |- P --> S  // The goal changes to `P --> S` because `S` implies `T`, as proven in the `by` clause.
    <-- R         by (R --> S)                    // Γ |- P --> R
    <-- Q         by (Q --> R)                    // Γ |- P --> Q
    <-- P         by (P --> Q)                    // In the last step we prove `P --> Q`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `impl-trans'` is
// this theorem: `forall Q R P : Prop, (Q --> R) --> (P --> Q) --> (P --> R)`
theorem implication-chaining-backwards-direct-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)
  apply (instantiate impl-trans' with S T P) (S --> T)
  apply (instantiate impl-trans' with R S P) (R --> S)
  apply (instantiate impl-trans' with Q R P) (Q --> R) (P --> Q)

// Besides backward chaining, there's also forward chaining. This time
// we start with a premise and draw intermediate conclusions from it,
// justifying each step, until we reach the goal.
theorem implication-chaining-forwards :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  // Let Γ := P --> Q, Q --> R, R --> S, S --> T
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)  // Γ |- P --> T  // After making all the assumptions, the goal is `P --> T`.
  chaining--> P                                   // Γ |- P --> T  // We start the chain. `-->` means it's forward chaining for implication. The goal is still `P --> T`.
    --> Q         by (P --> Q)                    // Γ |- Q --> T  // The goal changes to `Q --> T` because `P` implies `Q`, as proven in the `by` clause.
    --> R         by (Q --> R)                    // Γ |- R --> T
    --> S         by (R --> S)                    // Γ |- S --> T
    --> T         by (S --> T)                    // In the last step we prove `S --> T`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `impl-trans` is
// this theorem: `forall P Q R : Prop, (P --> Q) --> (Q --> R) --> (P --> R)`.
theorem implication-chaining-forwards-desugared :
  (P --> Q) --> (Q --> R) --> (R --> S) --> (S --> T) --> P --> T :=
  assume (P --> Q) (Q --> R) (R --> S) (S --> T)
  apply (instantiate impl-trans with P Q T) (P --> Q)
  apply (instantiate impl-trans with Q R T) (Q --> R)
  apply (instantiate impl-trans with R S T) (R --> S) (S --> T)

// We can also use chaining for biconditionals. The only "mode" of chaining
// here is forward (although I think backwards would also be possible).
theorem biconditional-chaining :
  (P <--> Q) --> (Q <--> R) --> (R <--> S) --> (S <--> T) --> P <--> T :=
  // Let Γ := P <--> Q, Q <--> R, R <--> S, S <--> T
  assume (P <--> Q) (Q <--> R) (R <--> S) (S <--> T)  // Γ |- P <--> T  // After making all the assumptions, the goal is `P <--> T`.
  chaining<--> P                                      // Γ |- P <--> T  // We start the chain. `<-->` means it's chaining for biconditional. The goal is still `P <--> T`.
    <--> Q        by (P <--> Q)                       // Γ |- Q <--> T  // The goal changes to `Q <--> T` because `P <--> Q`, as proven in the `by` clause.
    <--> R        by (Q <--> R)                       // Γ |- R <--> T
    <--> S        by (R <--> S)                       // Γ |- S <--> T
    <--> T        by (S <--> T)                       // In the last step we prove `S <--> T`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `iff-trans` is
// this theorem: `forall P Q R : Prop, (P <--> Q) --> (Q <--> R) --> (P <--> R)`.
theorem biconditional-chaining-desugared :
  (P <--> Q) --> (Q <--> R) --> (R <--> S) --> (S <--> T) --> P <--> T :=
  assume (P <--> Q) (Q <--> R) (R <--> S) (S <--> T)
  apply (instantiate iff-trans with P Q T) (P <--> Q)
  apply (instantiate iff-trans with Q R T) (Q <--> R)
  apply (instantiate iff-trans with R S T) (R <--> S) (S <--> T)

// Let's declare a type `A` and a predicate `P`. Note that up to this point `P`
// referred to a proposition, but from now on it will refer to a predicate.
type A
declaration P : A -> Prop

// Equational chaining also supports directly proving equalities.
theorem equational-chaining-direct :
  forall x y z w : A,
    x = y --> y = z --> z = w --> x = w :=
  pick-any x y z w
  // Let Γ := x y z w : A, x = y, y = z, z = w
  assume (x = y) (y = z) (z = w)  // Γ |- x = w  // After making all the assumptions, the goal is `x = w`.
  chaining= x                     // Γ |- x = w  // We start the chain. `=` means it's chaining for equality. The goal is still `x = w`.
    = y        by (x = y)         // Γ |- y = w  // The goal changes to `y = w` because `x = y`, as proven in the `by` clause.
    = z        by (y = z)         // Γ |- z = w
    = w        by (z = w)         // In the last step we prove `z = w`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `eq-trans` is
// this theorem: `forall (A : Type) (x y z : A), x = y --> y = z --> x = z`.
theorem equational-chaining-desugared :
  forall x y z w : A,
    x = y --> y = z --> z = w --> x = w :=
  pick-any x y z w
  assume (x = y) (y = z) (z = w)
  apply (instantiate eq-trans with A x y w) (x = y)
  apply (instantiate eq-trans with A y z w) (y = z) (z = w)

// Let's declare a transitive relation on `A`. Note that up to this point `R`
// referred to a proposition, but from now on it will refer to a relation.
// The command `axiom name : prop` declares that the proposition `prop` is true.
declaration R : A -> A -> Prop
axiom trans : forall x y z : A, R x y --> R y z --> R x z

// Chaining can be used for proofs about any transitive relation.
theorem relational-chaining :
  forall a b c d e : A,
    R a b --> R b c --> R c d --> R d e --> R a e :=
  pick-any a b c d e
  // Let Γ := R a b, R b c, R c d, R d e
  assume (R a b) (R b c) (R c d) (R d e)  // Γ |- R a e // After making all the assumptions, the goal is `R a e`.
  chaining R a                            // Γ |- R a e // We start the chain. `chaining R` means it's chaining for the relation `R`. The goal is still `R a e`.
    R b           by (R a b)              // Γ |- R b e // The goal changes to `R b e` because `R a b`, as proven in the `by` clause, and because `R` is transitive.
    R c           by (R b c)              // Γ |- R c e
    R d           by (R c d)              // Γ |- R d e
    R e           by (R d e)              // In the last step we prove `R d e`, which is precisely our goal, so we're done.

// The above proof is desugared as follows, where `trans` is
// the assumption that establishes the transitivity of `R`.
theorem relational-chaining-desugared :
  forall a b c d e : A,
    R a b --> R b c --> R c d --> R d e --> R a e :=
  pick-any a b c d e
  assume (R a b) (R b c) (R c d) (R d e)
  apply (instantiate trans with a b e) (R a b)
  apply (instantiate trans with b c e) (R b c)
  apply (instantiate trans with c d e) (R c d) (R d e)

// TODO: mixed chaining, like x <= y < z or x < y = z