// Term definition
answer : Nat := 42

// Type annotations at the top-level are mandatory, so the code below
// results in an error, even though it's easy to infer the type.
missing-annotation-error := 42

// Function definition (lambda).
id : Nat -> Nat :=
  fun n : Nat => n

// Function definition (no annotation on the binder).
id : Nat -> Nat :=
  fun n => n

// Function definition (short, arguments on the left).
id (n : Nat) : Nat := n

// Polymorphic function (lambda).
id : forall a, a -> a :=
  fun x : a => x

// Polymorphic function (short).
id a (x : a) : a := x

// Polymorphic function (very implicit arguments - no need to bind a).
id (x : a) : a := x

// Function composition.
comp (f : a -> b) (g : b -> c) : a -> c :=
  fun x => g (f x)

// Term declaration - `n` is now a natural number (which is otherwise undefined).
declaration n : Nat

// Theorem (tactic style).
theorem comp_id_l :=
  forall a b (f : a -> b), comp f id = f
proof
  pick-any a b f
  funext x
  refl
qed

// Theorem (term style, nameless)
theorem forall a b (f : a -> b), comp f id = f :=
  pick-any a b f in funext x in refl

// Nameless axiom
axiom 2 + 2 = 42

// Named axiom
axiom why-not-lol := False

// Type definition (synonym)
type NatToNat := Nat -> Nat

// Type definition (record)
type Point := {x of Nat; y of Nat}

// Type definition (variant)
type Bool :=
| no
| yes

// Type definition (polymorphic variant)
type Option a :=
| no
| yes of a

type Sum a b :=
| no of a
| yes of b

// Type definition (inductive)
type List a :=
| nil
| cons of {hd : a; tl : List a}

// Type declaration
type T

// Recursive functions
map a b (f : a -> b) (l : List a) : List b :=
| nil => nil
| cons h t => cons (f h) (map f t)

app a (l1 l2 : List a) : List a :=
| nil, _ => l2
| cons h t , _ => cons h (app t l2)

// Proof by induction
theorem map-id :=
  forall a (l : List a). map id l = l
proof
  pick-any a l
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl
qed

theorem map-id-term-style : forall a l. map id l = l :=
  pick-any a l in
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl

// Relation declaration
declaration R : Nat -> Nat -> Prop

// Polymorphic relation declaration
declaration R : forall A : Type, A -> A -> Prop

// Proposition definition
and (P Q : Prop) : Prop := P /\ Q
or (P Q : Prop) : Prop := P \/ Q
impl (P Q : Prop) : Prop := P --> Q
iff (P Q : Prop) : Prop := P <--> Q
not (P : Prop) : Prop := ~ P