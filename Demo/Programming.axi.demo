// In this file, we will describe the basics of programming.
// Since the programming layer is much more amorphous and
// underspecified in comparison to the logic layer, this part
// of the demo will be much further from the final product
// than the logical part. But we must show something, so we
// will stick to a core language in this file and describe
// its possible extensions with various language features
// in separate files.

// This core language consists of:
// - A mechanism for defining new programs and types.
// - Base types.
// - Functions.
// - Polymorphism.
// - Records.
// - Inductive data types and recursive functions.
// - Typeclasses.
// - Proof principles needed to reason about the above.

// We will NOT describe the following:
// - Modules.
// - Monads, effects or other means of interacting with the blockchain.
// - Blockchain specific features, like constraints or pub-sub.
// - Cryptography.

// In later files, we will describe features such as:
// - Termination checker.
// - Linear typing.
// - Structural records and variants (in the core language, they are nominal).
// - Subtyping.
// - And possibly more...

// The syntax for a definition is `name : type := body`.
answer : Int32 := 42

// Type annotations at the top-level are mandatory, so the code below
// results in an error, even though it's easy to infer the type.
missingAnnotationError := 42

// To replace a definition with its body in a proof, we can use `unfold`.
theorem unfold-example : answer = 42
proof              // |- answer = 42
  unfold answer    // |- 42 = 42
  refl
qed

// In proofterm style, it doesn't make much sense to use `unfold`,
// because its results are only visible in the goal, which is only
// visible in tactic mode.
theorem unfold-example-term-style : answer = 42 :=
  unfold answer in
    refl

// To define a type synonym, we can use the syntax `type name := body`.
type MediumSizedInt := Int32

// We can use such a type just as any other.
anotherAnswer : MediumSizedInt := 42

// To see that `MediumSizedInt` is considered equal to `Int32`, it
// suffices to state the following theorem. If these types were
// different, we would get a type error, but the theorem is accepted
// and we can proceed to prove it.
// Also note that to `unfold` multiple definitions, we separate them
// with commas.
theorem type-synonym-example : anotherAnswer = answer
proof
  unfold anotherAnswer, answer
  refl
qed

// The exact set of base types is left more or less unspecified.
// I imagine there will be `Int`s, `Uint`s and `Float`s of multiple sizes,
// as well as `String`s and `Char`acters, together with support for their
// literals. On the blockchain side, there might be types for `Address`es,
// `Hash`es, etc.

// `Int`s of various sizes.
int8Example  : Int8  := -100
int16Example : Int16 := 0
int32Example : Int32 := 42
int64Example : Int64 := 2^32

// `Uint`s of various sizes.
uint8Example :  Uint8  := 42
uint16Example : Uint16 := 42
uint32Example : Uint32 := 42
uint64Example : Uint64 := 42

// `Float`s of various sizes.
float8Example  : Float8  := 1.0
float16Example : Float16 := 2.8e13
float32Example : Float32 := 0.4e-6
float64Example : Float64 := NaN

// Characters.
charExample : Char := '\n'

// Strings.
stringExample : String := "where lambo?"

// `t : A` is a type annotation. We can use it to give a hint to make
// the type checker think that `t` has type `A`, but only if it can
// check that this is indeed the case.
// As an example, we can use an annotation to make the type checker
// think that `1` is a float, even though it is ordinarily an int.
annotationExample : Float32 :=
  1 : Float32

// The syntax for anonymous functions is `fun x : A => e`.
idNat : Nat -> Nat :=
  fun n : Nat => n

// To simplify an expression to its result, use the `simpl` tactic.
theorem simpl-example : idNat 42 = 42
proof             // |- idNat 42 = 42
  unfold idNat    // |- (fun n : Nat => n) 42 = 42
  simpl           // |- 42 = 42
  refl
qed

// `simpl` doesn't make much sense in proofterm style,
// because it only affects the goal.
theorem simpl-exampl-term-style : idNat 42 = 42 :=
  unfold idNat in
    simpl in
      refl

// When a definition needs to be unfolded to perform simplification,
// `simpl` can do it.
theorem simpl-without-unfold : idNat 42 = 42
proof                    // |- idNat 42 = 42
  simpl                  // |- 42 = 42
  refl
qed

// Of course since both `unfold` and `simpl` work only to change how the goal
// is displayed, to prove the above theorems it suffice to use `refl`.
theorem refl-is-enough : idNat 42 = 42
proof
  refl
qed

// We don't need to put a type annotation on the binder if it can be inferred.
idNat' : Nat -> Nat :=
  fun n => n

// Even though we did not write the annotation on the binder,
// it will be present whne the definition is unfolded.
theorem no-annotation-desugared : idNat' = (fun n : Nat => n)
proof                       // |- idNat' = (fun n : Nat => n)
  unfold idNat'             // |- (fun n : Nat => n) = (fun n : Nat => n)
  refl
qed

// We can make the definition shorter by putting all arguments on
// the left-hand side.
idNat'' (n : Nat) : Nat := n

// The short definition produces the same term as the other two definitions.
theorem short-definition-desugared : idNat'' = (fun n : Nat => n)
proof                          // |- idNat'' = (fun n : Nat => n)
  unfold idNat'                // |- (fun n : Nat => n) = (fun n : Nat => n)
  refl
qed

// Functions enjoy definitional extensionality, i.e. a function
// `f` is equal to `fun x => f x` and this can be proved with `refl`.
theorem definitional-funext-example :
  forall (A B : Type) (f : A -> B),
    f = fun x : A => f x
proof
  pick-any A B f
  refl
qed

// To define a polymorphic function, we use the quantifier `forall A : Type`
// in the function's type. Note that in the term, we don't need to bind the
// type with `fun` - type abstractions are implicit by default.
id : forall A : Type, A -> A :=
  fun x : A => x

// To state a theorem about a polymorphic function, we can use `forall` as
// a quantifier in the logic. Note that we write `id x`, without mentioning
// the type `A` - type applications are implicit by default.
theorem id-spec :
  forall (A : Type) (x : A),
    id x = x
proof
  pick-any A x
  refl
qed

// Just as for monomorphic functions, we can put all the arguments on the
// left-hand side to make the definition much shorter.
id' (A : Type) (x : A) : A := x

// An interesting feature borrowed from Idris 2 are very implicit arguments -
// we can recognize that `A` is a universally quantified type, even though
// this was not explicitly written. However, this will only be possible when
// the type variable is a single uppercase letter.
id'' (x : A) : A := x

// If two functions return the same result for all arguments, they are equal.
// This principle is called (propositional) function extensionality.
// Formally, `funext x in e` proves `f = g` when `e` proves `f x = g x`
// in the context extended with `x : A`.
theorem funext-example :
  forall (A B : Type) (f g : A -> B),
    (forall x : A, f x = g x) --> f = g
proof
  pick-any A B f g
  // Let Γ := A B : Type, f g : A -> B, eq := forall x : A, f x = g x
  assume (eq := _)  // Γ |- f = g
  funext x          // Γ, x : A |- f x = g x
  instantiate eq
qed

// We can use `let` bindings.
letExample (a b : Float32) : Float32 :=
  let x := a + b in
    let y := a - b in
      x * y

// In case we have more than one `let` binding, we can group them in a block.
letBlockExample (a b : Float32) : Float32 :=
  let
    x := a + b
    y := a - b
  in
    x * y

// We may put type annotations on variables in `let`s.
annotatedLetExample (a b : Float32) : Float32 :=
  let
    x : Float32 := a + b
    y : Float32 := a - b
  in
    x * y

// When we encounter a `let` binding in a proof, we can get rid of it
// with `simpl`.
theorem let-computation-example :
  forall (A : Type) (e1 e2 : A),
    (let x := e1 in e2) = (fun x => e2) e1
proof
  pick-any A e1 e2  // A : Type, e1 e2 : A |- (let x := e1 in e2) = (fun x => e2) e1
  simpl             // A : Type, e1 e2 : A |- (fun x => e2) e1 = (fun x => e2) e1
  refl
qed

// We can define record types using a pretty familiar syntax.
// We use the keyword `of` to declare the fields' types.
type Point :=
{
  x of Float32
  y of Float32
}

// In a record type `T` with field `f of A`,
// `f` is a function of type `T -> A`.
fieldTypeExample : Point -> Float32 := x

// We can access record fields using the familiar dot syntax.
dotSyntaxExample (p : Point) : Float32 := p.x

// However, presumably we can also access fields using
// ordinary function application syntax.
alternativeFieldAccessExample (p : Point) : Float32 := x p

// As a third possibility, we can `open` a record and refer to the fields
// directly, without dot syntax or having to apply them.
recordOpeningExample (p : Point) : Float32 :=
  open p in x

// We can build records with record literal syntax.
recordLiteralSyntaxExample : Point :=
{
  x := 1.0
  y := 1e10
}

// We can also write record literals inline.
inlineRecordLiteralExample : Point := {x := 1.0; y := 1e10}

// Records, similarly to functions, enjoy definitional extensionality.
theorem definitional-record-extensionality-example :
  forall p : Point,
    p = {x := p.x; y := p.y}
proof
  pick-any p
  refl
qed

// Because of the above, we can prove record equality component-wise.
theorem record-equality-example :
  forall p1 p2 : Point,
    p1.x = p2.x --> p1.y = p2.y --> p1 = p2
proof
  pick-any p1 p2
  assume (eqx eqy := _)
  chaining= p1
    = {x := p1.x; y := p1.y}  by refl
    = {x := p2.x; y := p1.y}  by eqx
    = {x := p2.x; y := p2.y}  by eqy
    = p2                      by refl
qed

// We can define another record type, `Point3D`, whose field names overlap
// with fields names of `Point`. At the top level this causes some ambiguity,
// but we will allow to disambiguate based on types or explicitly.
type Point3D :=
{
  x of Float32
  y of Float32
  z of Float32
}

// We can explicitly disambiguate between the `x` from `Point` and the
// one from `Point3D` using dot syntax.
explicitDisambiguationExample : Point3D -> Float32 :=
  Point3D.x

// We can also disambiguate implicitly, based on types.
implicitDisambiguationExample : Point3D -> Float32 := x

// Any kind of conversion between these two records must be performed
// manually.
projectToXY (p : Point3D) : Point :=
  {x := p.x; y := p.y}

embedInXYZ (p : Point) : Point3D :=
  {x := p.x; y := p.y; z := 0.0}

// Records can be polymorphic, just like functions.
// We can implement pairs as polymorphic records.
type Prod A B :=
{
  fst of A;
  snd of B;
}

// We can also use tuple syntax for records, but only if
// the type of the record can be inferred. In particular,
// this can always be done at the top level.
tupleSyntaxExample : Prod Int32 Float32 := (42, 3.14)

// As an alternative way of eliminating records, we can
// pattern match on them, using both record literal syntax
// and tuple syntax.
swapRecord (A B : Type) (p : Prod A B) : Prod B A :=
| {x := x; y := y} => {x := y; y := x}

swapTuple (A B : Type) (p : Prod A B) : Prod B A :=
| (x, y) => (y, x)

// We can also pattern match on a record in a `let` binding.
swapLet (A B : Type) (p : Prod A B) : Prod B A :=
  let (x, y) := p in (y, x)

// We can define inductive types with a convenient syntax.
// Note that the first pipe `|` is mandatory.
// Also note that we use `yes` and `no` as names of the booleans,
// to make it easier for newcomers not to confuse them with the
// propositions `True` and `False`.
type Bool :=
| no
| yes

// We can define functions out of inductive types by pattern matching.
notb (b : Bool) : Bool :=
| no  => yes
| yes => no

// We can reason by cases on elements of inductive types using `cases`.
theorem notb-notb :
  forall b : Bool,
    notb (notb b) = b
proof                  // forall b : Bool, notb (notb b) = b
  pick-any b           // b : Bool |- notb (notb b) = b
  cases b
  | no =>              // |- notb (notb no) = no
    simpl              // |- no = no
    refl
  | yes =>             // |- notb (notb yes) = yes
    simpl              // |- yes = yes
    refl
qed

// In proofterm style, the above proof looks as follows.
theorem notb-notb-term-style :
  forall b : Bool,
    notb (notb b) = b :=
  pick-any b in
    cases b of
    | no  => simpl in refl
    | yes => simpl in refl

// We can match one more than one argument at a time.
andb (b1 b2 : Bool) : Bool :=
| no , _   => no
| _  , no  => no
| yes, yes => yes

// Similarly, we can reason by cases on more than one term.
theorem andb-comm :
  forall b1 b2 : Bool,
    andb b1 b2 = andb b2 b1
proof
  pick-any b1 b2
  cases b1, b2
  | no , no  => refl
  | no , yes => refl
  | yes, no  => refl
  | yes, yes => refl
qed

// Inductive types can be polymorphic.
// We use the keyword `of` to declare the constructors' argument types.
type Option A :=
| none
| some of A

// For an inductive type `T` with a constructor `c of A`,
// `c` is a function of type `A -> T`.
constructorTypeExample : forall A : Type, A -> Option A := some

type Sum A B :=
| inl of A
| inr of B

swapSum (A B : Type) (x : Sum A B) : Sum B A :=
| inl a => inr a
| inr b => inl b

// Type definition (inductive)
type List A :=
| nil
| cons of {hd of A; tl of List A}

// Recursive functions
map (f : A -> B) (l : List A) : List B :=
| nil => nil
| cons h t => cons (f h) (map f t)

app (l1 l2 : List A) : List A :=
| nil, _ => l2
| cons h t , _ => cons h (app t l2)

// Proof by induction
theorem map-id :
  forall A (l : List A), map id l = l
proof
  pick-any A l
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl
qed

theorem map-id-term-style : forall A l, map id l = l :=
  pick-any A l in
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl



// Our core language also has a simple type class mechanism.
// Type classes are more or less equivalent to records with
// type parameters, with some special syntax to make use of
// them in type signatures.
class Eq (A : Type) :=
{
  eqb : A -> A -> 
}

// Relation declaration
declaration R : Nat -> Nat -> Prop

// Polymorphic relation declaration
declaration R : forall A : Type, A -> A -> Prop

// Proposition definition
and (P Q : Prop) : Prop := P /\ Q
or (P Q : Prop) : Prop := P \/ Q
impl (P Q : Prop) : Prop := P --> Q
iff (P Q : Prop) : Prop := P <--> Q
not (P : Prop) : Prop := ~ P