// This is a comment.

// The basic kinds of objects are terms, types, propositions and proofs.
// Top-level commands can be used to either define or declare these.
// Declarations introduce new constants whereas definitions assign names to
// expressions. Whether declarations should be present in the final language is
// unclear (as they correspond to axioms and may result in contradiction), but
// they are present in comparable languages, so I've included them for now.

// Term definition
answer : Nat := 42

// Function definition (lambda).
id : Nat -> Nat :=
  fun n : Nat => n

// Function definition (no annotation on the binder).
id : Nat -> Nat :=
  fun n => n

// Function definition (short, arguments on the left).
id (n : Nat) : Nat := n

// Polymorphic function (lambda).
id : forall a, a -> a :=
  fun x : a => x

// Polymorphic function (short).
id (x : a) : a := x

// Polymorphic function (very implicit arguments - no need to bind a).
id (x : a) : a := x

// Function composition.
comp (f : a -> b) (g : b -> c) : a -> c :=
  fun x => g (f x)

// Term declaration - n is now a natural number (which is otherwise undefined).
declaration n : Nat

// Theorem (tactic style).
theorem comp_id_l :=
  forall a b (f : a -> b), comp f id = f
proof
  pick-any a b f
  funext x
  refl
qed

// Theorem (term style, nameless)
theorem forall a b (f : a -> b). comp f id = f :=
  pick-any a b f in funext x in refl

// Nameless axiom
axiom 2 + 2 = 42

// Named axiom
axiom why-not-lol := False

// Type definition (synonym)
type NatToNat := Nat -> Nat

// Type definition (record)
type Point := {x of Nat; y of Nat}

// Type definition (variant)
type Bool :=
| no
| yes

// Type definition (polymorphic variant)
type Option a :=
| no
| yes of a

type Sum a b :=
| no of a
| yes of b

// Type definition (inductive)
type List a :=
| nil
| cons of {hd : a; tl : List a}

// Type declaration
type T

// Recursive functions
map a b (f : a -> b) (l : List a) : List b :=
| nil => nil
| cons h t => cons (f h) (map f t)

app a (l1 l2 : List a) : List a :=
| nil, _ => l2
| cons h t , _ => cons h (app t l2)

// Proof by induction
theorem map_id :=
  forall a (l : List a). map id l = l
proof
  pick-any a l
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl
qed

theorem map_id : forall a l. map id l = l :=
  pick-any a l =>
  induction l
  | nil => refl
  | cons => rewrite (map id t = t) in refl

// Relation declaration
relation R : Nat -> Nat -> Prop

// Alternative version
proposition R (n m : Nat)

// Polymorphic
proposition R a (x y : a)

// Proposition definition
proposition and P Q := P /\ Q
proposition or P Q := P \/ Q
proposition impl P Q := P --> Q
proposition iff P Q := P <--> Q
proposition not P := ~ P