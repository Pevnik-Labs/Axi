\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usepackage{AxiCommands}

\newcommand{\implintro}[2]{\textbf{assume}\ #1\ \textbf{in}\ #2}
\newcommand{\implelim}[2]{\textbf{modus-ponens}\ #1\ #2}
\newcommand{\true}{\textbf{true}}
\newcommand{\exfalso}[1]{\textbf{exfalso}\ #1}
\newcommand{\prooflet}[2]{#1; #2}
\newcommand{\notintro}[2]{\textbf{suppose-absurd}\ #1\ \textbf{in}\ #2}
\newcommand{\notelim}[2]{\textbf{absurd}\ #1\ #2}
\newcommand{\andintro}[2]{\textbf{both}\ #1\ #2}
\newcommand{\andeliml}[1]{\textbf{left-and}\ #1}
\newcommand{\andelimr}[1]{\textbf{right-and}\ #1}
\newcommand{\orintrol}[2]{\textbf{left-either}\ #1\ #2}
\newcommand{\orintror}[2]{\textbf{right-either}\ #1\ #2}
\newcommand{\orelim}[3]{\textbf{constructive-dilemma}\ #1\ #2\ #3}
\newcommand{\iffintro}[2]{\textbf{equivalence}\ #1\ #2}
\newcommand{\iffeliml}[1]{\textbf{left-iff}\ #1}
\newcommand{\iffelimr}[1]{\textbf{right-iff}\ #1}

\newcommand{\dn}[1]{\textbf{double-negation}\ #1}

\newcommand{\allintro}[2]{\textbf{pick-any}\ #1\ \textbf{in}\ #2}
\newcommand{\allelim}[2]{\textbf{specialize}\ #1\ \textbf{with}\ #2}
\newcommand{\exintro}[2]{\textbf{exists}\ #1\ \textbf{such that}\ #2}
\newcommand{\exelim}[3]{\textbf{pick-witness}\ #1\ \textbf{for}\ #2\ \textbf{in}\ #3}


\newcommand{\sumind}[5]{\textbf{case}\ #1\ \textbf{of}\ (\inl{#2} \rightarrow #3, \inr{#4} \rightarrow #5)}

\newcommand{\refl}[1]{\textbf{refl}\ #1}
\newcommand{\rewrite}[2]{\textbf{rewrite}\ #1\ \textbf{in}\ #2}
\newcommand{\funext}[1]{\textbf{funext}\ #1}

\newcommand{\fullproves}[4]{#1 \pipe #2 \vdash #3 : #4}
\newcommand{\proves}[2]{\fullproves{\Gamma}{\Delta}{#1}{#2}}

\usetheme{Darmstadt}

\title{Poor Man's Axi: DPL-like proofs in Type Theory}
\author{Wojciech Ko≈Çowski}
\date{}

\begin{document}

\frame{\titlepage}

\section{Intro}

\begin{frame}{Layers in Poor Man's Axi}

In our original proposal of Poor Man's Axi, the language was split into two layers:

\begin{itemize}
  \item A programming layer which consists of a strongly-typed functional programming language based on the Simply Typed Lambda Calculus.
  \item A logical layer which consists of second-order classical logic with equality and some primitives for reasoning by cases and induction (note that it's not full second-order logic, because it only allows quantification over functions, but not over propositions, predicates or relations).
\end{itemize}

\end{frame}

\begin{frame}{Logic without proofterms}

The logic was presented with a bunch of judgements, the most important being the true proposition judgement $\holds{P}$. While this presentation does a good job of explaining what the logic is like, it does not address the problem of writing proofs from the perspective of the programmer.

\end{frame}

\begin{frame}{Logic with proofterms}

To deal with this problem, we introduce proofterms (also known as proof certificates), which are expressions that will serve as the ``proofs'' that the user will write. The manipulation of judgements which establish their correctness (which we will describe soon) is left to the language's proof checker.

\end{frame}

\begin{frame}{Proofterms}

Proofterms (here $P$ are propositions, $t$ are terms, $x$ are variables): \\
$e ::=$ \\
\qquad $P \pipe \true \pipe \exfalso{e}$ \\
\qquad $\implintro{P}{e} \pipe \implelim{e_1}{e_2} \pipe$ \\
\qquad $\notintro{P}{e} \pipe \notelim{e_1}{e_2} \pipe$ \\
\qquad $\andintro{e_1}{e_2} \pipe \andeliml{e} \pipe \andelimr{e} \pipe$ \\
\qquad $\iffintro{e_1}{e_2} \pipe \iffeliml{e} \pipe \iffelimr{e} \pipe$ \\
\qquad $\orintrol{P}{e} \pipe \orintror{P}{e} \pipe$ \\
\qquad $\orelim{e_1}{e_2}{e_3} \pipe$ \\
\qquad $\dn{e} \pipe$ \\
\qquad $\prooflet{e_1}{e_2} \pipe$ \\
\qquad $\allintro{x}{e} \pipe \allelim{e}{t} \pipe$ \\
\qquad $\exintro{t}{e} \pipe \exelim{x}{e_1}{e_2} \pipe$ \\
\qquad $\refl{t} \pipe \rewrite{e_1}{e_2} \pipe$ \\
\qquad $\sumind{t}{a}{e_1}{b}{e_2} \pipe$

\end{frame}

\begin{frame}{Proofterms -- overview}

A quick glance at the above grammar:

\begin{itemize}
  \item First, propositions are included in the syntactic category of proofterms, because we will refer to an assumption $P$ with $P$ itself.
  \item Then we have some proofterms for dealing with propositional logic, divided as usual into introduction and elimination forms.
  \item $\textbf{double-negation}$ is our way of making the logic classical.
  \item $\prooflet{e_1}{e_2}$ is a cut (or, in programming language terms, a let-expression, although without any variable binding).
  \item Then we have some proofterms to deal with quantifiers.
  \item $\textbf{refl}$ and $\textbf{rewrite}$ are primitives for dealing with equality.
  \item Finally, $\textbf{case}$ will be used for reasoning by cases on terms of type $\Sum{A}{B}$.
\end{itemize}

\end{frame}

\section{Examples}

\begin{frame}{Examples}

Before we jump right into the rules, let's see some examples. The point of the first two is to show that our proofterms look very similar to proofs from DPLs. The third example shows how simple reasoning about programs might look like.

\end{frame}

\begin{frame}{Example -- propositional logic}

Theorem: $\Impl{(\Impl{P}{Q})}{\Impl{(\Impl{Q}{R})}{\Impl{P}{R}}}$.

\vspace{2em}

Proof: \\
$\implintro{\Impl{P}{Q}}{}$ \\
\, $\implintro{\Impl{Q}{R}}{}$ \\
\quad $\implintro{P}{}$ \\
\qquad $\implelim{(\Impl{P}{Q})}{P};$ \\
\qquad $\implelim{(\Impl{Q}{R})}{Q}$

\vspace{2em}

The proof looks the same as the DPL one (page 71 in the DPL thesis), except that we don't have $\textbf{begin}$ and $\textbf{end}$.

\end{frame}

\begin{frame}{Example -- first-order logic}

Theorem: $\Impl{(\All{x}{A}{\And{\app{P}{x}}{\app{Q}{x}}})}{\And{(\All{x}{A}{\app{P}{x}})}{(\All{x}{A}{\app{Q}{x}})}}$

\vspace{2em}

Proof: \\
$\implintro{\All{x}{A}{\And{\app{P}{x}}{\app{Q}{x}}}}{}$ \\
\quad $\allintro{y}{}$ \\
\qquad $\allelim{\All{x}{A}{\And{\app{P}{x}}{\app{Q}{x}}}}{y};$ \\
\qquad $\andeliml{\And{\app{P}{y}}{\app{Q}{y}}}$; \\
\quad $\allintro{y}{}$ \\
\qquad $\allelim{\All{x}{A}{\And{\app{P}{x}}{\app{Q}{x}}}}{y};$ \\
\qquad $\andelimr{\And{\app{P}{y}}{\app{Q}{y}}}$; \\
\quad $\andintro{(\All{y}{A}{\app{P}{y}})}{(\All{y}{A}{\app{Q}{y}})}$ \\

\vspace{2em}

Again, the proof looks the same as the DPL one (page 156 in the DPL thesis), except we use indentation instead of $\textbf{begin}$ and $\textbf{end}$.
\end{frame}

\newcommand{\swap}[1][]{\texttt{swap}\ #1}

\begin{frame}{Example -- proof about a program}

Consider the following program: \\
$\texttt{swap} : \Fun{\Sum{A}{B}}{\Sum{B}{A}} := \fun{x}{\case{x}{\fun{a}{\inr[a]}}{\fun{b}{\inl[b]}}}$ \\

\vspace{2em}

It's pretty clear that this function is an involution. \\
Theorem: $\All{x}{\Sum{A}{B}}{\Eq[]{\swap{(\swap{x})}}{x}}$

\vspace{1em}

Proof: \\
$\allintro{x}{}$ \\
\quad $\sumind{x}{a}{\refl{a}}{b}{\refl{b}}$

\vspace{2em}

The proof has the same structure as the proofterm you would write in Coq, except for the syntactic differences.

\end{frame}

\section{Rules}

\begin{frame}{Correct proof judgement}

We now proceed to describe proofterms in much greater detail. will modify the language in the following way: we throw away the true proposition judgement $\holds{P}$ and replace it with the correct proof judgement $\proves{e}{P}$ which should be read: in typing context $\Gamma$ and assumption context $\Delta$, $e$ is a proof of $P$.

\vspace{2em}

The other judgements we need in our logic, the valid assumption context judgement $\assctx{\Gamma}{\Delta}$ and the well-formed proposition judgement $\prop{\Gamma}{P}$, are unchanged. Note that we will set up the system so that $\proves{e}{P}$ entails $\assctx{\Gamma}{\Delta}$ and $\prop{\Gamma}{P}$ as sanity checks.


\end{frame}

\begin{frame}{Assumptions}

\begin{center}
  $\infrule[Ass]{\assctx{\Gamma}{\Delta} \quad \sidecond{P \in \Delta}}{\proves{P}{P}}$
\end{center}

\vspace{2em}

The basic rule of our logic is that we can use assumptions from the assumption context. Note that here $P$ denotes both the proposition and its proof.

\end{frame}

\begin{frame}{True and false}

\begin{center}
  $\infrule[True-Intro]{\assctx{\Gamma}{\Delta}}{\proves{\true}{\True}}$

  \vspace{2em}

  $\infrule[False-Elim]{\proves{e}{\False}}{\proves{\exfalso{e}}{P}}$
\end{center}

\vspace{2em}

$\true$ establishes the truth of the true proposition $\True$, whereas $\exfalso{e}$ proves any proposition $P$ whatsoever, provided that $e$ proves $\False$.

\end{frame}

\begin{frame}{Implication}

\begin{center}
  $\infrule[Impl-Intro]{\fullproves{\Gamma}{\assume{\Delta}{P}}{e}{Q}}{\proves{\implintro{P}{e}}{\Impl{P}{Q}}}$

  \vspace{2em}

  $\infrule[Impl-Elim]{\proves{e_1}{\Impl{P}{Q}} \quad \proves{e_2}{P}}{\proves{\implelim{e_1}{e_2}}{Q}}$
\end{center}

\end{frame}

\begin{frame}{Conjunction}

\begin{center}
  $\infrule[And-Intro]{\proves{e_1}{P} \quad \proves{e_2}{Q}}{\proves{\andintro{e_1}{e_2}}{\And{P}{Q}}}$

  \vspace{2em}

  $\infrule[And-Elim-L]{\proves{e}{\And{P}{Q}}}{\proves{\andeliml{e}}{P}}$

  \vspace{2em}

  $\infrule[And-Elim-R]{\proves{e}{\And{P}{Q}}}{\proves{\andelimr{e}}{Q}}$
\end{center}

\end{frame}

\begin{frame}{Disjunction}

\begin{center}
  $\infrule[Or-Intro-L]{\proves{e}{P}}{\proves{\orintrol{Q}{e}}{\Or{P}{Q}}}$

  \vspace{2em}

  $\infrule[Or-Intro-R]{\proves{e}{Q}}{\proves{\orintror{P}{e}}{\Or{P}{Q}}}$

  \vspace{2em}

  $\infrule[Or-Elim]{\proves{e_1}{\Or{P}{Q}} \quad \proves{e_2}{\Impl{P}{R}} \quad \proves{e_3}{\Impl{Q}{R}}}{\proves{\orelim{e_1}{e_2}{e_3}}{R}}$
\end{center}

\end{frame}

\begin{frame}{Biconditional}

\begin{center}
  $\infrule[Iff-Intro]{\proves{e_1}{\Impl{P}{Q}} \quad \proves{e_2}{\Impl{Q}{P}}}{\proves{\iffintro{e_1}{e_2}}{\Iff{P}{Q}}}$

  \vspace{2em}

  $\infrule[Iff-Elim-L]{\proves{e}{\Iff{P}{Q}}}{\proves{\iffeliml{e}}{\Impl{P}{Q}}}$

  \vspace{2em}

  $\infrule[Iff-Elim-R]{\proves{e}{\Iff{P}{Q}}}{\proves{\iffelimr{e}}{\Impl{Q}{P}}}$
\end{center}

\end{frame}

\begin{frame}{Negation}

\begin{center}
  $\infrule[Not-Intro]{\fullproves{\Gamma}{\assume{\Delta}{P}}{e}{\False}}{\proves{\notintro{P}{e}}{\Not{P}}}$

  \vspace{2em}

  $\infrule[Not-Elim]{\proves{e_1}{\Not{P}} \quad \proves{e_2}{P}}{\proves{\notelim{e_1}{e_2}}{\False}}$
\end{center}

\end{frame}

\begin{frame}{Classical logic}

\begin{center}
  $\infrule[Classic]{\proves{e}{\Not{\Not{P}}}}{\proves{\dn{e}}{P}}$
\end{center}

\end{frame}

\begin{frame}{Proof composition (or let binding, really)}

\begin{center}
  $\infrule[Cut]{\proves{e_1}{P} \quad \fullproves{\Gamma}{\assume{\Delta}{P}}{e_2}{Q}}{\proves{\prooflet{e_1}{e_2}}{Q}}$
\end{center}

\end{frame}

\begin{frame}{Universal quantifier}

\begin{center}
  $\infrule[Forall-Intro]{\fullproves{\extend{\Gamma}{y}{A}}{\Delta}{e}{\subst{P}{x}{y}}}{\proves{\allintro{y}{e}}{\All{x}{A}{P}}}$

  \vspace{2em}

  $\infrule[Forall-Elim]{\proves{e}{\All{x}{A}{P}} \quad \typing{t}{A}}{\proves{\allelim{e}{t}}{\subst{P}{x}{t}}}$
\end{center}

\end{frame}

\begin{frame}{Existential quantifier}

\begin{center}
  $\infrule[Exists-Intro]{\typing{t}{A} \quad \proves{e}{\subst{P}{x}{t}}}{\proves{\exintro{t}{e}}{\Ex{x}{A}{P}}}$

  \vspace{2em}

  $\infrule[Exists-Elim]{\prop{\Gamma}{R} \quad \proves{e_1}{\Ex{x}{A}{P}} \quad \fullproves{\extend{\Gamma}{y}{A}}{\assume{\Delta}{\subst{P}{x}{y}}}{e_2}{R}}{\proves{\exelim{y}{e_1}{e_2}}{R}}$
\end{center}

\end{frame}

\begin{frame}{Reasoning by cases on terms (for sums)}

\begin{center}
  $\infrule{\prop{\extend{\Gamma}{x}{A}}{P} \quad \typing{t}{\Sum{A}{B}} \quad \begin{array}{c} \fullproves{\extend{\Gamma}{a}{A}}{\Delta}{e_1}{\subst{P}{x}{\inl[a]}} \\ \fullproves{\extend{\Gamma}{b}{B}}{\Delta}{e_2}{\subst{P}{x}{\inr[b]}} \end{array}}{\proves{\sumind{t}{a}{e_1}{b}{e_2}}{\subst{P}{x}{t}}}$
\end{center}

\end{frame}

\begin{frame}{Equality}

\begin{center}
  $\infrule[Eq-Intro]{\assctx{\Gamma}{\Delta} \quad \typing{t}{A}}{\proves{\refl{t}}{\Eq[A]{t}{t}}}$

  \vspace{2em}

  $\infrule[Eq-Elim]{\proves{e}{\Eq[A]{t_1}{t_2}} \quad \prop{\extend{\Gamma}{x}{A}}{P} \quad \proves{e'}{\subst{P}{x}{t_1}}}{\proves{\rewrite{e}{e'}}{\subst{P}{x}{t_2}}}$
\end{center}

\end{frame}

\begin{frame}{Equality of functions}

\begin{center}
  $\infrule[Funext]{\proves{e}{\All{x}{A}{\Eq[B]{\app{f}{x}}{\app{g}{x}}}}}{\proves{\funext{e}}{\Eq[\Fun{A}{B}]{f}{g}}}$
\end{center}

\end{frame}

\begin{frame}{Conversion rule}

\begin{center}
  $\infrule[Conv]{\prop{\extend{\Gamma}{x}{A}}{P} \quad \proves{e}{\subst{P}{x}{t_1}} \quad \computation{t_1}{t_2}{A}}{\proves{e}{\subst{P}{x}{t_2}}}$
\end{center}

\end{frame}

\end{document}