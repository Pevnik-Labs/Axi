-- File generated by the BNF Converter (bnfc 2.9.5).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE OverloadedStrings #-}

-- | The abstract syntax of language Syntax.

module Syntax.Abs where

import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

data Repl = LetR [Dec] | ExpR Exp | RequireR Str
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Dec
    = StructureD StructureKwd Rule
    | ConstantD Rule
    | ProofD [ProofStep]
    | DeclarationD Patterns
    | PipeClauseD PipeClause
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data StructureKwd
    = DataKwd
    | RecordKwd
    | ModuleKwd
    | ClassKwd
    | InstanceKwd
    | AxiomKwd
    | TheoremKwd
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Rule
    = ByBlockR Pat [ProofStep]
    | ProofR Pat [ProofStep]
    | ValueR Pat Exp
    | WhereR Pat [Dec]
    | SigR Pat
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data ProofStep
    = ProofDecPS ProofDec
    | BulletBlockPS [ProofStep]
    | CasesPS [Exp]
    | CasesWithPS [Exp]
    | InductionPS [Exp]
    | PipeClausePS PipeClause
    | ProvingPS Exp
    | ApplyPS Exp [Exp]
    | InstantiatePS Exp
    | IntroPS Patterns
    | WitnessPS ExpOpt
    | ExpPS Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data ProofDec
    = AssumePD Patterns
    | ByContradictionPD Pat AnnOpt
    | LetPD [Dec]
    | LemmaPD Rule
    | OpenPD Id
    | PickAnyPD Patterns
    | PickWitnessPD Patterns Exp
    | ChainingPD [ChainLink]
    | RewritePD [RewriteItem]
    | UnfoldPD [Pat]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data ChainLink = EasyCL ChainOp Exp | ByCL ChainOp Exp [ProofStep]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data ChainOp
    = LeftLongArrowCO
    | LeftArrowCO
    | RightLongArrowCO
    | RightArrowCO
    | EqCO
    | EqualCO
    | EquivCO
    | ExpCO Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data RewriteItem = MkRI DirectionOpt Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data DirectionOpt = LeftDO | RightDO | NoDO
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Patterns = MkP [Param] AnnOpt
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Param = ArgP Decor Pat
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Decor = Bare | At | Hash
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Pat
    = NoncomputableP Pat
    | TypeP Pat
    | PropP Pat
    | CtorAnnP Pat [Exp]
    | SuperAnnP Pat [Exp]
    | SubAnnP Pat [Exp]
    | AnnP Pat Exp
    | OrP Pat Pat
    | AndP Pat Pat
    | IndP Pat
    | CallP Pat Param [Param]
    | NumberP Number
    | CharP Chr
    | StringP Str
    | HoleP Hole
    | VarP Id
    | RecordP [FieldPat]
    | TupleP Pat [Pat]
    | UnitP
    | WitnessP Pat Pat
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data FieldPat = PunP Id | FieldP Id Pat
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data AnnOpt = HasAnn Exp | NoAnn
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data ExpOpt = HasExp Exp | NoExp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Exp
    = EqE Exp Exp
    | ApplyE Exp
    | ProofDecInE ProofDec Exp
    | WitnessSuchThatE [Exp] Exp
    | AnnE Exp Exp
    | LamE [Param] Exp
    | ProvingByE ExpOpt [ProofStep]
    | SufficesByE Exp [ProofStep]
    | ExistsE Patterns Exp
    | ForallE Patterns Exp
    | ArrowE Exp Exp
    | ImplicationE Exp Exp
    | EquivalenceE Exp Exp
    | DisjunctionE Exp Exp
    | ConjunctionE Exp Exp
    | NegationE Exp
    | EqualE Exp Exp
    | CallE Exp [Arg]
    | ExplicitE Id
    | LamCasesE Patterns [Clause]
    | CaseE Exp [Clause]
    | MatchWith Exp [PipeClause]
    | InstantiateWithE Exp
    | UnitE
    | TupleE Exp [Exp]
    | RecordE [Dec]
    | RecordUpdateE Exp [Dec]
    | AssumptionE
    | NumberE Number
    | CharE Chr
    | StringE Str
    | HoleE Hole
    | VarE Id
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Clause = MkC [Param] Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data PipeClause = MkPC [Pat] [ProofStep]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Arg = ArgE Decor Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

bareA :: Exp -> Arg
bareA = \ e -> ArgE Bare e

atA :: Exp -> Arg
atA = \ e -> ArgE At e

newtype Number = Number Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Chr = Chr Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Str = Str Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Hole = Hole Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Id = Id ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Id where
  hasPosition (Id (p, _)) = C.Just p

instance Data.String.IsString Id where
  fromString s = Id ((0, 0), Data.Text.pack s)

