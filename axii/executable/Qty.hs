{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE ViewPatterns #-}

module Qty where

import Data.Data (Data)
import Data.Maybe (fromMaybe)
import Data.Ratio (denominator, numerator)

infix 4 <~, <:

-- | Positive commutative semiring of multiplicative idempotents.
--
-- Quantities have two kinds of division: integral and fractional.
-- * 'div' and 'mod' satisfy @div x y * y + mod x y == x@,
-- * @z '/' y@ is the greatest @x@ such that @x * y <~ z@.
--
-- Subsemirings:
-- * {0,1,+} generated by {}
-- * {0,1,+,*} generated by {*}
-- * {0,1,?,+,*} generated by {?}
data Qty
  = -- | Unrestricted (*): zero or more uses, additive idempotent.
    Un
  | -- | Relevant (+): one or more uses, additive absorber.
    Re
  | -- | Affine (?): zero or one uses, the generator of the semiring.
    Af
  | -- | Linear (1): exactly one use, multiplicative neutral.
    Li
  | -- | Erased (0): exactly zero uses, additive neutral, mult. absorber.
    Er
  deriving (Eq, Ord, Read, Show, Enum, Bounded, Data)

instance Num Qty where
  fromInteger 0 = Er
  fromInteger 1 = Li
  fromInteger n | n >= 2 = Re
  fromInteger _ = error "fromInteger{Qty}: negative integer"
  Er + r = r
  r + Er = r
  r + _ | Re <~ r = Re
  _ + r | Re <~ r = Re
  _ + _ = Un
  r - s | Just d <- diffQty r s = d
  _ - _ = error "(-){Qty}: underflow"
  _ * Er = Er
  Er * _ = Er
  r * Li = r
  Li * r = r
  Af * Af = Af
  Re * Re = Re
  _ * _ = Un
  abs Er = Af
  abs r = r
  signum Er = Er
  signum _ = Li

instance Real Qty where
  toRational Er = 0
  toRational Li = 1
  toRational Re = 2
  toRational _ = error "toRational{Qty}: not a number"

instance Integral Qty where
  toInteger Er = 0
  toInteger Li = 1
  toInteger Re = 2
  toInteger _ = error "toInteger{Qty}: not a number"
  divMod r Er = (Un, r)
  divMod Er _ = (Er, Er)
  divMod Li Li = (Li, Er)
  divMod Li _ = (Er, Li)
  divMod Af r | Af <~ r = (Af, Er)
  divMod Af _ = (Er, Af)
  divMod Re r | Re <~ r = (Re, Un)
  divMod Re _ = (Un, Re)
  divMod Un _ = (Un, Un)
  quotRem = divMod

instance Fractional Qty where
  fromRational q = fromInteger (numerator q) / fromInteger (denominator q)
  r / s | Just q <- s <: r = q
  _ / _ = error "(/){Qty}: division by zero"

-- | Complete partial order (CPO) with maximal elements 0 and 1.
(<~) :: Qty -> Qty -> Bool
Un <~ _ = True
Re <~ Li = True
Af <~ Li = True
Af <~ Er = True
r <~ s = r == s

-- | The greatest @q@ such that @l * q <~ r@ - right residual of @r@ by @l@.
(<:) :: Qty -> Qty -> Maybe Qty
_ <: Er = Just Er
Er <: _ = Nothing
l <: Un = complQty l
l <: r = Just (if l <~ r then Li else r)

-- | Is the quantity '(<~)' maximal?
maximal :: Qty -> Bool
maximal Er = True
maximal Li = True
maximal _ = False

-- | Upper sets of the CPO.
upperQty :: Qty -> [Qty]
upperQty Er = [Er]
upperQty Li = [Li]
upperQty Af = [Af, Li, Er]
upperQty Re = [Re, Li]
upperQty Un = [Un, Re, Af, Li, Er]

-- | Meet semilattice action of the CPO.
infQty :: Qty -> Qty -> Qty
infQty Er Er = Er
infQty r s = abs r * abs s

-- | Join semilattice action of the CPO.
supQtyMay :: Qty -> Qty -> Maybe Qty
supQtyMay Re Af = Just Li
supQtyMay Af Re = Just Li
supQtyMay r s = if r <~ s || s <~ r then Just (max r s) else Nothing

-- | Join semilattice action of the CPO, returns 'Er' if undefined.
supQty :: Qty -> Qty -> Qty
supQty r s = fromMaybe Er (supQtyMay r s)

-- | Complement: @(r *) <$> complQty r = Just Un@ if defined.
complQty :: Qty -> Maybe Qty
complQty Er = Nothing
complQty Li = Just Un
complQty Af = Just Re
complQty Re = Just Af
complQty Un = Just Li

-- | @diffQty x y@ is the '<~' supremum of @{r | x <~ r + y}@
diffQty :: Qty -> Qty -> Maybe Qty
diffQty r Er = Just r
diffQty Er _ = Nothing
diffQty Li Li = Just 0
diffQty Li _ = Nothing
diffQty Af r | Af <~ r = Just Er
diffQty Af _ = Nothing
diffQty Re r | Re <~ r = Just Un
diffQty Re _ = Just Re
diffQty Un _ = Just Un

suffixQty :: Qty -> String
suffixQty Er = "0"
suffixQty Li = "1"
suffixQty Af = "?"
suffixQty Re = "+"
suffixQty Un = ""

infixr 5 :#

pattern (:#) :: Qty -> [Qty] -> [Qty]
pattern q :# qs <- (\case [] -> (Er, []); q : qs -> (q, qs) -> (q, qs))
  where
    q :# qs = q : qs

{-# COMPLETE (:#) #-}
