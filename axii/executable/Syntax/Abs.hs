-- File generated by the BNF Converter (bnfc 2.9.5).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Syntax.

module Syntax.Abs where

import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type Repl = Repl' BNFC'Position
data Repl' a = LetR a [Dec' a] | ExpR a (Exp' a) | RequireR a Str
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Dec = Dec' BNFC'Position
data Dec' a
    = StructureD a (StructureKwd' a) (Rule' a)
    | ConstantD a (Rule' a)
    | ProofD a [ProofStep' a]
    | DeclarationD a (Patterns' a)
    | PipeClauseD a (PipeClause' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type StructureKwd = StructureKwd' BNFC'Position
data StructureKwd' a
    = DataKwd a
    | RecordKwd a
    | ModuleKwd a
    | ClassKwd a
    | InstanceKwd a
    | AxiomKwd a
    | TheoremKwd a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Rule = Rule' BNFC'Position
data Rule' a
    = ByBlockR a (Pat' a) [ProofStep' a]
    | ProofR a (Pat' a) [ProofStep' a]
    | ValueR a (Pat' a) (Exp' a)
    | WhereR a (Pat' a) [Dec' a]
    | SigR a (Pat' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ProofStep = ProofStep' BNFC'Position
data ProofStep' a
    = ProofDecPS a (ProofDec' a)
    | BulletBlockPS a [ProofStep' a]
    | CasesPS a [Exp' a]
    | CasesWithPS a [Exp' a]
    | InductionPS a [Exp' a]
    | PipeClausePS a (PipeClause' a)
    | ProvingPS a (Exp' a)
    | ApplyPS a (Exp' a) [Exp' a]
    | InstantiatePS a (Exp' a)
    | IntroPS a (Patterns' a)
    | WitnessPS a (ExpOpt' a)
    | ExpPS a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ProofDec = ProofDec' BNFC'Position
data ProofDec' a
    = AssumePD a (Patterns' a)
    | ByContradictionPD a (Pat' a) (TypeAnnOpt' a)
    | LetPD a [Dec' a]
    | LemmaPD a (Rule' a)
    | OpenPD a Id
    | PickAnyPD a (Patterns' a)
    | PickWitnessPD a (Patterns' a) (Exp' a)
    | ChainingPD a [ChainLink' a]
    | RewritePD a [RewriteItem' a]
    | UnfoldPD a [Pat' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ChainLink = ChainLink' BNFC'Position
data ChainLink' a
    = EasyCL a (ChainOp' a) (Exp' a)
    | ByCL a (ChainOp' a) (Exp' a) [ProofStep' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ChainOp = ChainOp' BNFC'Position
data ChainOp' a
    = LeftLongArrowCO a
    | LeftArrowCO a
    | RightLongArrowCO a
    | RightArrowCO a
    | EqCO a
    | EqualCO a
    | EquivCO a
    | ExpCO a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type RewriteItem = RewriteItem' BNFC'Position
data RewriteItem' a = MkRI a (DirectionOpt' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type DirectionOpt = DirectionOpt' BNFC'Position
data DirectionOpt' a = LeftDO a | RightDO a | NoDO a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Patterns = Patterns' BNFC'Position
data Patterns' a = MkP a [Param' a] (TypeAnnOpt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Param = Param' BNFC'Position
data Param' a
    = BareP a (Pat' a) | ExplicitP a (Pat' a) | InvisibleP a (Pat' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Pat = Pat' BNFC'Position
data Pat' a
    = NoncomputableP a (Pat' a)
    | TypeP a (Pat' a)
    | PropP a (Pat' a)
    | CtorAnnP a (Pat' a) [Exp' a]
    | SuperAnnP a (Pat' a) [Exp' a]
    | SubAnnP a (Pat' a) [Exp' a]
    | AnnP a (Pat' a) (Exp' a)
    | OrP a (Pat' a) (Pat' a)
    | AndP a (Pat' a) (Pat' a)
    | IndP a (Pat' a)
    | CallP a (Pat' a) (Param' a) [Param' a]
    | NumberP a Number
    | CharP a Chr
    | StringP a Str
    | HoleP a Hole
    | VarP a Id
    | RecordP a [FieldPat' a]
    | TupleP a (Pat' a) [Pat' a]
    | UnitP a
    | WitnessP a (Pat' a) (Pat' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type FieldPat = FieldPat' BNFC'Position
data FieldPat' a = PunP a Id | FieldP a Id (Pat' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type TypeAnnOpt = TypeAnnOpt' BNFC'Position
data TypeAnnOpt' a = HasTAO a (Exp' a) | NoTAO a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ExpOpt = ExpOpt' BNFC'Position
data ExpOpt' a = HasEO a (Exp' a) | NoEO a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Exp = Exp' BNFC'Position
data Exp' a
    = EqE a (Exp' a) (Exp' a)
    | ApplyE a (Exp' a)
    | ProofDecInE a (ProofDec' a) (Exp' a)
    | WitnessSuchThatE a [Exp' a] (Exp' a)
    | AnnE a (Exp' a) (Exp' a)
    | FunE a [Param' a] (Exp' a)
    | ProvingByE a (ExpOpt' a) [ProofStep' a]
    | SufficesByE a (Exp' a) [ProofStep' a]
    | ExistsE a (Patterns' a) (Exp' a)
    | ForallE a (Patterns' a) (Exp' a)
    | ArrowE a (Exp' a) (Exp' a)
    | ImplicationE a (Exp' a) (Exp' a)
    | EquivalenceE a (Exp' a) (Exp' a)
    | DisjunctionE a (Exp' a) (Exp' a)
    | ConjunctionE a (Exp' a) (Exp' a)
    | NegationE a (Exp' a)
    | EqualE a (Exp' a) (Exp' a)
    | CallE a (Exp' a) [Arg' a]
    | ExplicitE a Id
    | LamCasesE a (Patterns' a) [Clause' a]
    | CaseE a (Exp' a) [Clause' a]
    | MatchWith a (Exp' a) [PipeClause' a]
    | InstantiateWithE a (Exp' a)
    | UnitE a
    | TupleE a (Exp' a) [Exp' a]
    | RecordE a [Dec' a]
    | RecordUpdateE a (Exp' a) [Dec' a]
    | AssumptionE a
    | NumberE a Number
    | CharE a Chr
    | StringE a Str
    | HoleE a Hole
    | VarE a Id
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Clause = Clause' BNFC'Position
data Clause' a = MkC a [Param' a] (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type PipeClause = PipeClause' BNFC'Position
data PipeClause' a = MkPC a [Pat' a] [ProofStep' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Arg = Arg' BNFC'Position
data Arg' a = BareA a (Exp' a) | ExplicitA a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype Number = Number Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Chr = Chr Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Str = Str Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Hole = Hole Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype Id = Id Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Repl where
  hasPosition = \case
    LetR p _ -> p
    ExpR p _ -> p
    RequireR p _ -> p

instance HasPosition Dec where
  hasPosition = \case
    StructureD p _ _ -> p
    ConstantD p _ -> p
    ProofD p _ -> p
    DeclarationD p _ -> p
    PipeClauseD p _ -> p

instance HasPosition StructureKwd where
  hasPosition = \case
    DataKwd p -> p
    RecordKwd p -> p
    ModuleKwd p -> p
    ClassKwd p -> p
    InstanceKwd p -> p
    AxiomKwd p -> p
    TheoremKwd p -> p

instance HasPosition Rule where
  hasPosition = \case
    ByBlockR p _ _ -> p
    ProofR p _ _ -> p
    ValueR p _ _ -> p
    WhereR p _ _ -> p
    SigR p _ -> p

instance HasPosition ProofStep where
  hasPosition = \case
    ProofDecPS p _ -> p
    BulletBlockPS p _ -> p
    CasesPS p _ -> p
    CasesWithPS p _ -> p
    InductionPS p _ -> p
    PipeClausePS p _ -> p
    ProvingPS p _ -> p
    ApplyPS p _ _ -> p
    InstantiatePS p _ -> p
    IntroPS p _ -> p
    WitnessPS p _ -> p
    ExpPS p _ -> p

instance HasPosition ProofDec where
  hasPosition = \case
    AssumePD p _ -> p
    ByContradictionPD p _ _ -> p
    LetPD p _ -> p
    LemmaPD p _ -> p
    OpenPD p _ -> p
    PickAnyPD p _ -> p
    PickWitnessPD p _ _ -> p
    ChainingPD p _ -> p
    RewritePD p _ -> p
    UnfoldPD p _ -> p

instance HasPosition ChainLink where
  hasPosition = \case
    EasyCL p _ _ -> p
    ByCL p _ _ _ -> p

instance HasPosition ChainOp where
  hasPosition = \case
    LeftLongArrowCO p -> p
    LeftArrowCO p -> p
    RightLongArrowCO p -> p
    RightArrowCO p -> p
    EqCO p -> p
    EqualCO p -> p
    EquivCO p -> p
    ExpCO p _ -> p

instance HasPosition RewriteItem where
  hasPosition = \case
    MkRI p _ _ -> p

instance HasPosition DirectionOpt where
  hasPosition = \case
    LeftDO p -> p
    RightDO p -> p
    NoDO p -> p

instance HasPosition Patterns where
  hasPosition = \case
    MkP p _ _ -> p

instance HasPosition Param where
  hasPosition = \case
    BareP p _ -> p
    ExplicitP p _ -> p
    InvisibleP p _ -> p

instance HasPosition Pat where
  hasPosition = \case
    NoncomputableP p _ -> p
    TypeP p _ -> p
    PropP p _ -> p
    CtorAnnP p _ _ -> p
    SuperAnnP p _ _ -> p
    SubAnnP p _ _ -> p
    AnnP p _ _ -> p
    OrP p _ _ -> p
    AndP p _ _ -> p
    IndP p _ -> p
    CallP p _ _ _ -> p
    NumberP p _ -> p
    CharP p _ -> p
    StringP p _ -> p
    HoleP p _ -> p
    VarP p _ -> p
    RecordP p _ -> p
    TupleP p _ _ -> p
    UnitP p -> p
    WitnessP p _ _ -> p

instance HasPosition FieldPat where
  hasPosition = \case
    PunP p _ -> p
    FieldP p _ _ -> p

instance HasPosition TypeAnnOpt where
  hasPosition = \case
    HasTAO p _ -> p
    NoTAO p -> p

instance HasPosition ExpOpt where
  hasPosition = \case
    HasEO p _ -> p
    NoEO p -> p

instance HasPosition Exp where
  hasPosition = \case
    EqE p _ _ -> p
    ApplyE p _ -> p
    ProofDecInE p _ _ -> p
    WitnessSuchThatE p _ _ -> p
    AnnE p _ _ -> p
    FunE p _ _ -> p
    ProvingByE p _ _ -> p
    SufficesByE p _ _ -> p
    ExistsE p _ _ -> p
    ForallE p _ _ -> p
    ArrowE p _ _ -> p
    ImplicationE p _ _ -> p
    EquivalenceE p _ _ -> p
    DisjunctionE p _ _ -> p
    ConjunctionE p _ _ -> p
    NegationE p _ -> p
    EqualE p _ _ -> p
    CallE p _ _ -> p
    ExplicitE p _ -> p
    LamCasesE p _ _ -> p
    CaseE p _ _ -> p
    MatchWith p _ _ -> p
    InstantiateWithE p _ -> p
    UnitE p -> p
    TupleE p _ _ -> p
    RecordE p _ -> p
    RecordUpdateE p _ _ -> p
    AssumptionE p -> p
    NumberE p _ -> p
    CharE p _ -> p
    StringE p _ -> p
    HoleE p _ -> p
    VarE p _ -> p

instance HasPosition Clause where
  hasPosition = \case
    MkC p _ _ -> p

instance HasPosition PipeClause where
  hasPosition = \case
    MkPC p _ _ -> p

instance HasPosition Arg where
  hasPosition = \case
    BareA p _ -> p
    ExplicitA p _ -> p

